#!/usr/bin/env python3

# TODO use class Row

import sys
import argparse
import subprocess as sp
import os
import stat
import os.path
from shutil import which
import time
# from pprint import pprint
import random
from datetime import datetime
from os.path import expanduser

from string import Template as Tm
from timeit import default_timer as timer

from process_timer import ProcessTimer

DEFAULT_PROGRAM_NAME = 'main'

SUPPORTED_OPERATIONS = ['Check', 'Compile', 'Build']

LANGUAGE_EXES = {'C': ['tcc', 'cuik', 'cproc', 'gcc', 'clang', ],
                 'C3': ['c3c', ],
                 'C++': ['g++', 'clang++', ],
                 'D': ['dmd', 'ldmd2', 'gdc', ],
                 'Zig': ['zig', ],
                 'Nim': ['nim', ],
                 'Rust': ['rustc', ],
                 'Ada': ['gnat', ],
                 'Vox': ['vox', ],
                 'C#': ['mcs',  # mcs is Mono C# compiler version 6.12.0.200
                        'csc'],  # csc is Microsoft (R) Visual C# Compiler
                 'Go': ['go', 'gccgo', ],
                 # 'V': ['v', ],
                 'Swift': ['swiftc', ],
                 'Java': ['javac', ],
                 'Julia': ['julia', ],
                 'OCaml': ['ocamlc', 'ocamlopt', ],
                 'Pareas': ['pareas', ],
                 'Mojo': ['mojo', ],
                 }
TEMPLATED_SUPPORTED_LANGUAGES = ['C++', 'Java', 'D', 'Swift', 'Vox', 'Rust',
                                 'Zig', 'V', 'C3', 'Julia', 'Mojo']

C_WARN_FLAGS = ['-Wall', '-Wextra']
CXX_WARN_FLAGS = ['-Wno-c++11-extensions']

RUSTC_NO_WARNINGS_FLAGS = ['-A', 'warnings']  # disable warnings for `rustc`
RUSTC_FLAGS = []  # set to `RUSTC_NO_WARNINGS_FLAGS` to disable warnings
RUSTC_NIGHTLY_FLAGS = ['-Z', 'threads=8']  # See: https://blog.rust-lang.org/2023/11/09/parallel-rustc.html

JULIA_INTERPRET_FLAGS = ['--compile=min']  # See: https://github.com/JuliaLang/julia/issues/41360#issuecomment-872075102
JULIA_COMPILE_FLAGS = ['-O0']  # See: https://github.com/JuliaLang/julia/issues/41360#issuecomment-872075102

ROOT_PATH = 'generated'
RANGE = range(5, 20)
VERSIONS = [''] + [f"-{i}" for i in RANGE]

# instead of home = os.getenv('HOME') that doesnâ€™t work on Windows
HOME = expanduser('~')


class Row:                      # TODO use
    """Result row."""
    __slots__ = ['lang',
                 'templated',
                 'check_dur_per_func',
                 'build_dur_per_func',
                 'run_dur_per_func',
                 'rss_mu',
                 'exe_version',
                 'exe_path']

    def __init__(self,
                 lang,
                 templated,
                 check_dur_per_func,
                 build_dur_per_func,
                 run_dur_per_func,
                 rss_mu,
                 exe_version,
                 exe_path):
        self.lang = lang
        self.templated = templated
        self.check_dur_per_func = check_dur_per_func
        self.build_dur_per_func = build_dur_per_func
        self.run_dur_per_func = run_dur_per_func
        self.rss_mu = rss_mu
        self.exe_version = exe_version
        self.exe_pat = exe_path


TABLE_TITLES = ['Lang-uage', 'Temp-lated', 'Check Time [us/fn]',
                'Compile Time [us/fn]', 'Build Time [us/fn]',
                'Run Time [us/fn]', 'Check RSS [kB/fn]', 'Build RSS [kB/fn]',
                'Exec Version', 'Exec Path']
LANG_IX = 0
TEMPLATED_IX = 1
CHECK_DUR_PER_FUNC_IX = 2       # check duration
COMPILE_DUR_PER_FUNC_IX = 3       # compilation duration
BUILD_DUR_PER_FUNC_IX = 4       # build duration
RUN_DUR_PER_FUNC_IX = 5       # run duration
CHECK_RSS_MU_IX = 6        # check RSS memory usage
BUILD_RSS_MU_IX = 7        # build RSS memory usage
EXE_VERSION_IX = 8
EXE_PATH_IX = 9
TABLE_LENGTH = EXE_PATH_IX + 1

assert len(TABLE_TITLES) == TABLE_LENGTH


def table_row(row,
              args,
              lang,
              op,
              exe_path,
              compiler_version,
              check_dur,
              compile_dur,
              build_dur,
              run_dur,
              check_rss_mu,
              build_rss_mu,
              templated):

    if exe_path.startswith(HOME):
        exe_path = os.path.join('~', exe_path.lstrip(HOME))

    row[LANG_IX] = lang
    row[TEMPLATED_IX] = 'Yes' if templated else 'No'

    if check_dur is not None:
        row[CHECK_DUR_PER_FUNC_IX] = check_dur / (args.function_count * args.function_depth)

    if compile_dur is not None:
        row[COMPILE_DUR_PER_FUNC_IX] = compile_dur / (args.function_count * args.function_depth)

    if build_dur is not None:
        row[BUILD_DUR_PER_FUNC_IX] = build_dur / (args.function_count * args.function_depth)

    if run_dur is not None:
        row[RUN_DUR_PER_FUNC_IX] = run_dur / (args.function_count * args.function_depth)

    if isinstance(check_rss_mu, (int, float)):
        row[CHECK_RSS_MU_IX] = check_rss_mu / (args.function_count * args.function_depth)
    elif check_rss_mu is not None:
        row[CHECK_RSS_MU_IX] = check_rss_mu

    if isinstance(build_rss_mu, (int, float)):
        row[BUILD_RSS_MU_IX] = build_rss_mu / (args.function_count * args.function_depth)
    elif build_rss_mu is not None:
        row[BUILD_RSS_MU_IX] = build_rss_mu

    row[EXE_VERSION_IX] = compiler_version
    row[EXE_PATH_IX] = os.path.basename(exe_path)

    return row


RANDOMIZE_FLAG = True

if RANDOMIZE_FLAG:
    random.seed(str(datetime.now()))


def get_version(version_run):
    result = next(part
                  for part
                  in version_run.stdout.decode('utf-8').split()
                  if (part[0].isdigit() or
                      part[0] == 'v' and part[1].isdigit()))  # v2.096.1-beta.1-187-gb25be89b3
    return result.split('~')[0].split('ubuntu1')[0]  # strip ubuntu version


def touchFile(path):
    with open(path, 'a'):
        os.utime(path, None)


def out_directory(lang):
    return os.path.join(ROOT_PATH,
                        lang.lower())


def out_binary(lang):
    return DEFAULT_PROGRAM_NAME


def sourceIdOf(lang, templated, run_ix):
    if lang in TEMPLATED_SUPPORTED_LANGUAGES:
        key = lang + ('-Templated' if templated else '-Untemplated')
    else:
        key = lang
    return key + "-" + str(run_ix)


def fill_in_speedups(results, column_ix):
    # calculate minimum
    min_key = None               # key of minimum
    min_val = None               # value of minimum
    for key, result in results.items():
        if isinstance(result[column_ix], (int, float)):
            if min_val is None or (min_val > result[column_ix]):
                min_key = key
                min_val = result[column_ix]
    if min_key is not None:
        rel_tag = results[min_key][EXE_PATH_IX]
        for key, result in results.items():
            result[column_ix] = stringify_metrics(abs_n=result[column_ix],
                                                  min_val=min_val,
                                                  column_ix=column_ix,
                                                  rel_tag=rel_tag)


def stringify_metrics(abs_n, min_val, column_ix, rel_tag):
    if isinstance(abs_n, str):
        return '{:>13}'.format(abs_n)            # propagate as is
    if abs_n is None:
        return '{:>6}'.format('N/A')  # https://en.wikipedia.org/wiki/N/A
    if abs_n == min_val:
        rel_str = " (best)"
    else:
        rel_n = abs_n / min_val
        rel_str = " (" + factor_str(rel_n) + "x" ")"
    if column_ix == CHECK_DUR_PER_FUNC_IX:
        return to_str_in_microseconds(abs_n) + rel_str
    elif column_ix == COMPILE_DUR_PER_FUNC_IX:
        return to_str_in_microseconds(abs_n) + rel_str
    elif column_ix == BUILD_DUR_PER_FUNC_IX:
        return to_str_in_microseconds(abs_n) + rel_str
    elif column_ix == RUN_DUR_PER_FUNC_IX:
        return to_str_in_nanoseconds(abs_n) + rel_str
    elif column_ix == CHECK_RSS_MU_IX:
        return to_str_memory_usage(abs_n) + rel_str
    elif column_ix == BUILD_RSS_MU_IX:
        return to_str_memory_usage(abs_n) + rel_str


def to_str_in_microseconds(dur):
    return '{:6.1f}'.format(1e6 * dur)


def to_str_in_nanoseconds(dur):
    return '{:6.0f}'.format(1e9 * dur) if dur is not None else ''


def factor_str(factor):
    return '{:.1f}'.format(factor)


def to_str_memory_usage(mu):
    return '{:6.1f}'.format(mu / 1e3)


def repeat_to_length(string_to_expand, length):
    return (string_to_expand * (int(length / len(string_to_expand)) + 1))[:length]


def markdown_header(text, nr):        # Markdown header
    return '#' * nr + ' ' + text


def markdown_table(titles, results):
    fill_in_speedups(results=results, column_ix=CHECK_DUR_PER_FUNC_IX)
    fill_in_speedups(results=results, column_ix=COMPILE_DUR_PER_FUNC_IX)
    fill_in_speedups(results=results, column_ix=BUILD_DUR_PER_FUNC_IX)
    fill_in_speedups(results=results, column_ix=RUN_DUR_PER_FUNC_IX)
    fill_in_speedups(results=results, column_ix=CHECK_RSS_MU_IX)
    fill_in_speedups(results=results, column_ix=BUILD_RSS_MU_IX)

    result = ''

    result += '| '
    for col in titles:
        result += str(col) + ' | '
    result += '\n'

    result += '| '
    for ix, col in enumerate(range(len(titles))):
        if ix == TEMPLATED_IX:
            result += repeat_to_length("-", len(titles[ix])) + ' | '
        else:
            result += ':' + repeat_to_length("-", len(titles[ix]) - 2) + ':' + ' | '
    result += '\n'

    for key, row in results.items():
        result += '| '
        for ix, cl in enumerate(range(len(titles))):
            col = row[ix]
            col_str = str(col) if col is not None else 'N/A'
            result += col_str + repeat_to_length(" ", len(titles[ix]) - len(col_str)) + ' | '
        result += '\n'
    return result


def match_lang_exe(args, lang, exe_name):
    try:
        if args.language_exes[lang] and exe_name not in args.language_exes[lang]:
            return None
    except KeyError:
        pass
    exe_path = which(exe_name)
    return exe_path


def bench_Ada_using_gcc(results, lang, code_paths, args, op, templated):
    exe_flags = ['compile'] if op == 'Build' else ['check']
    for gcc_version in VERSIONS:
        exe = match_lang_exe(args, lang, 'gnat' + str(gcc_version))
        if exe:
            version = get_version(sp.run([exe, '--version'], stdout=sp.PIPE))
            compile_file(code_paths,
                         out_flag_and_exe=['-o', out_binary(lang)],
                         exe=exe,
                         runner=True,
                         exe_flags=exe_flags,
                         args=args,
                         op=op,
                         compiler_version=version,
                         lang=lang,
                         templated=templated,
                         results=results)


def bench_C_using_cproc(results, lang, code_paths, args, op, templated):
    if op == 'Check':
        exe_flags = ['-emit-qbe']
        out_flag_and_exe = ['-o', '/dev/null']
    elif op == 'Compile':
        exe_flags = ['-c']
        out_flag_and_exe = ['-o', '/dev/null']
    elif op == 'Build':
        exe_flags = []
        out_flag_and_exe = ['-o', out_binary(lang)]
        # Disable build for now until I find out how to fix linker errors:
        # ld: error: unable to find library -l:crt1.o
        # ld: error: unable to find library -l:crti.o
        # ld: error: unable to find library -lc
        # ld: error: unable to find library -l:crtn.o
        # cproc: link: process 2424876 exited with status 1
        return False
    else:
        return None
    exe = match_lang_exe(args, lang, 'cproc')
    if exe:
        version = 'unknown'
        compile_file(code_paths,
                     out_flag_and_exe=out_flag_and_exe,
                     exe=exe,
                     runner=(op == 'Build'),
                     exe_flags=exe_flags,
                     args=args,
                     op=op,
                     compiler_version=version,
                     lang=lang,
                     templated=templated,
                     results=results)


def bench_C_using_tcc(results, lang, code_paths, args, op, templated):
    if op == 'Check':
        exe_flags = ['-c']
        out_flag_and_exe = ['-o', '/dev/null']
    elif op == 'Compile':
        exe_flags = ['-c']
        out_flag_and_exe = []
    elif op == 'Build':
        exe_flags = []  # TODO add version that skips linking via: exe_flags = ['-c']
        out_flag_and_exe = ['-o', out_binary(lang)]
    else:
        return None
    exe = match_lang_exe(args, lang, 'tcc')
    if exe:
        version = get_version(sp.run([exe, '-v'], stdout=sp.PIPE))
        compile_file(code_paths,
                     out_flag_and_exe=out_flag_and_exe,
                     exe=exe,
                     runner=(op == 'Build'),
                     exe_flags=exe_flags,
                     args=args,
                     op=op,
                     compiler_version=version,
                     lang=lang,
                     templated=templated,
                     results=results)


def bench_C_using_cuik(results, lang, code_paths, args, op, templated):
    if op == 'Check':
        exe_flags = ['-c', '-xe']
        out_flag_and_exe = []
    elif op == 'Compile':
        exe_flags = ['-c']
        out_flag_and_exe = []
    elif op == 'Build':
        exe_flags = []  # TODO add version that skips linking via: exe_flags = ['-c']
        out_flag_and_exe = ['-o', out_binary(lang)]
    else:
        return None
    exe = match_lang_exe(args, lang, 'cuik')
    if exe:
        version = "~master"
        compile_file(code_paths,
                     out_flag_and_exe=out_flag_and_exe,
                     exe=exe,
                     runner=(op == 'Build'),
                     exe_flags=exe_flags,
                     args=args,
                     op=op,
                     compiler_version=version,
                     lang=lang,
                     templated=templated,
                     results=results)


def gcc_clang_op_flags(op, lang):
    if op == 'Check':
        exe_flags = ['-c', '-fsyntax-only']
        out_flag_and_exe = []
    elif op == 'Compile':
        exe_flags = ['-c']
        out_flag_and_exe = []
    elif op == 'Build':
        exe_flags = []  # TODO add version that skips linking via: exe_flags = ['-c']
        out_flag_and_exe = ['-o', out_binary(lang)]
    else:
        return (None, None)
    return (exe_flags, out_flag_and_exe)


def bench_C_and_Cxx_using_gcc(results, lang, code_paths, args, op,
                                  templated):
    (exe_flags, out_flag_and_exe) = gcc_clang_op_flags(op, lang)
    if exe_flags is None:
        return None
    FLAGS = []
    if lang == 'C':
        FLAGS = C_WARN_FLAGS
    elif lang == 'C++':
        FLAGS = CXX_WARN_FLAGS
    for gcc_version in VERSIONS:
        if lang == 'C':
            exe = match_lang_exe(args, lang, 'gcc' + str(gcc_version))
        elif lang == 'C++':
            exe = match_lang_exe(args, lang, 'g++' + str(gcc_version))
        else:
            return None
        if exe:
            output = sp.run([exe, '--version'], stdout=sp.PIPE).stdout
            version = output.decode('utf-8').split()[2].split('-')[0]
            compile_file(code_paths,
                         out_flag_and_exe=out_flag_and_exe,
                         exe=exe,
                         runner=True,
                         exe_flags=exe_flags + FLAGS,
                         args=args,
                         op=op,
                         compiler_version=version,
                         lang=lang,
                         templated=templated,
                         results=results)


def bench_C_and_Cxx_using_clang(results, lang, code_paths, args, op,
                                    templated):
    (exe_flags, out_flag_and_exe) = gcc_clang_op_flags(op, lang)
    if exe_flags is None:
        return None
    FLAGS = []
    if lang == 'C':
        FLAGS = C_WARN_FLAGS + ['-fno-color-diagnostics', '-fno-caret-diagnostics', '-fno-diagnostics-show-option']
    elif lang == 'C++':
        FLAGS = CXX_WARN_FLAGS
    for clang_version in VERSIONS:
        if lang == 'C':
            exe = match_lang_exe(args, lang, 'clang' + str(clang_version))
        elif lang == 'C++':
            exe = match_lang_exe(args, lang, 'clang' + str(clang_version))
        else:
            return None
        if exe:
            version = get_version(sp.run([exe, '--version'], stdout=sp.PIPE))
            compile_file(code_paths,
                         out_flag_and_exe=out_flag_and_exe,
                         exe=exe,
                         runner=True,
                         exe_flags=FLAGS + exe_flags,
                         args=args,
                         op=op,
                         compiler_version=version,
                         lang=lang,
                         templated=templated,
                         results=results)


def bench_D(results, code_paths, args, op, templated, use_dips):
    lang = 'D'
    d_flags = ['-w', '-dip1008', '-dip1000'] if use_dips else []

    if op == 'Check':
        exe_flags = ['-o-']
    elif op == 'Compile':
        exe_flags = ['-c']
    elif op == 'Build':
        if which('ld.lld') is not None:
            exe_flags = ["-Xcc=-fuse-ld=lld"]
        elif which('ld.gold') is not None:
            exe_flags = ["-Xcc=-fuse-ld=gold"]
        else:
            exe_flags = []
    else:
        return None

    try:
        exes = args.language_exes[lang]
    except KeyError:
        return
    if not exes:
        exes = LANGUAGE_EXES[lang]

    # dmd
    for exe in filter(lambda exe: which(exe), exes):
        if not which(exe):
            continue
        if exe.startswith('dmd'):
            version = get_version(sp.run([exe, '--version'], stdout=sp.PIPE))
            compile_file(code_paths=code_paths,
                         out_flag_and_exe=['-of=' + out_binary(lang)] if op == 'Build' else [],
                         exe=exe,
                         runner=True,
                         exe_flags=d_flags + exe_flags,
                         args=args,
                         op=op,
                         compiler_version=version,
                         lang=lang,
                         templated=templated,
                         results=results)
        elif exe.startswith('ldmd2'):
            version = sp.run([exe, '--version'], stdout=sp.PIPE).stdout.decode('utf-8').split()[6][1:-2]
            compile_file(code_paths=code_paths,
                         out_flag_and_exe=['-of=' + out_binary(lang)] if op == 'Build' else [],
                         exe=exe,
                         runner=True,
                         exe_flags=d_flags + exe_flags,
                         args=args,
                         op=op,
                         compiler_version=version,
                         lang=lang,
                         templated=templated,
                         results=results)
        elif exe.startswith('gdc'):
            exe_flags = ['-fsyntax-only'] if op == 'Check' else []
            version = sp.run([exe, '--version'], stdout=sp.PIPE).stdout.decode('utf-8').split()[3]
            compile_file(code_paths=code_paths,
                         out_flag_and_exe=['-o' + out_binary(lang)] if op == 'Build' else [],
                         exe=exe,
                         runner=True,
                         exe_flags=exe_flags,
                         args=args,
                         op=op,
                         compiler_version=version,
                         lang=lang,
                         templated=templated,
                         results=results)


def bench_Vox(results, code_paths, args, op, templated):
    lang = 'Vox'
    if op == 'Check':
        exe_flags = ['--check-only']
        out_flag_and_exe = []
    elif op == 'Compile':
        return None             # no supported
    elif op == 'Build':
        exe_flags = []
        out_flag_and_exe = ['--of=' + out_binary(lang)]
    else:
        return None
    exe = match_lang_exe(args, lang, 'vox')
    if exe:
        compile_file(code_paths,
                     out_flag_and_exe=out_flag_and_exe,
                     exe=exe,
                     runner=True,  # os.name == 'nt', # only on Windows for now. TODO https://forum.dlang.org/post/cjbaiikzfbqkjqoukljc@forum.dlang.org
                     exe_flags=exe_flags,
                     args=args,
                     op=op,
                     compiler_version='master',  # TODO lookup Git version
                     lang=lang,
                     templated=templated,
                     results=results)


def bench_CSharp_using_mono(results, code_paths, args, op, templated):
    lang = 'C#'
    exe = match_lang_exe(args, lang, 'mcs')
    if exe:
        exe_flags = ['-target:exe'] + ([] if op == 'Build' else [''])
        version = sp.run([exe, '--version'], stdout=sp.PIPE).stdout.decode('utf-8').split()[4]
        compile_file(code_paths,
                     out_flag_and_exe=['-out:' + out_binary(lang)],
                     exe=exe,
                     runner=True,
                     exe_flags=exe_flags,
                     args=args,
                     op=op,
                     compiler_version=version,
                     lang=lang,
                     templated=templated,
                     results=results)


def bench_CSharp_using_csc(results, code_paths, args, op, templated):
    lang = 'C#'
    exe = match_lang_exe(args, lang, 'csc')
    if exe:
        exe_flags = ['-target:exe'] + ([] if op == 'Build' else [''])
        version = sp.run([exe, '-version'], stdout=sp.PIPE).stdout.decode('utf-8').split()[0]
        print(version)
        compile_file(code_paths,
                     out_flag_and_exe=['-out:' + out_binary(lang)],
                     exe=exe,
                     runner=True,
                     exe_flags=exe_flags,
                     args=args,
                     op=op,
                     compiler_version=version,
                     lang=lang,
                     templated=templated,
                     results=results)


def bench_Go(results, code_paths, args, op, templated):
    bench_Go_using_go(results, code_paths, args, op, templated)
    bench_Go_using_gccgo(results, code_paths, args, op, templated)


def bench_Go_using_go(results, code_paths, args, op, templated):
    lang = 'Go'
    version = None              # unknown
    if op == 'Build':
        exe = which('go')
        exe_flags = ['build']
        version = sp.run([exe, 'version'], stdout=sp.PIPE).stdout.decode('utf-8').split()[2][2:]
        out_flag_and_exe = ['-o', out_binary(lang)]
    elif op == 'Check':
        exe = which('gotype')
        exe_flags = []
        version_exe = which('go')  # guess it be same as `go`
        if version_exe is not None:
            version = sp.run([version_exe, 'version'], stdout=sp.PIPE).stdout.decode('utf-8').split()[2][2:]
        out_flag_and_exe = []
    else:
        return None
    exe = match_lang_exe(args, lang, exe)
    if exe:
        compile_file(code_paths,
                     out_flag_and_exe=out_flag_and_exe,
                     exe=exe,
                     runner=True,
                     exe_flags=exe_flags,
                     args=args,
                     op=op,
                     compiler_version=version,
                     lang=lang,
                     templated=templated,
                     results=results)


def bench_Go_using_gccgo(results, code_paths, args, op, templated):
    lang = 'Go'
    for gccgo_version in VERSIONS:
        exe = match_lang_exe(args, lang, 'gccgo' + str(gccgo_version))
        if exe:
            version = sp.run([exe, '--version'], stdout=sp.PIPE).stdout.decode('utf-8').split()[3]
            compile_file(code_paths,
                         out_flag_and_exe=[],  # TODO this fails out_flag_and_exe=['-o', out_binary(lang)],
                         exe=exe,
                         runner=True,
                         exe_flags=[] if op == 'Build' else ['-fsyntax-only', '-S'],
                         args=args,
                         op=op,
                         compiler_version=version,
                         lang=lang,
                         templated=templated,
                         results=results)


def bench_Swift(results, code_paths, args, op, templated):
    lang = 'Swift'
    exe = (match_lang_exe(args, lang, 'swiftc') or
           which(os.path.join(HOME, '.local/swift-5.3.3-RELEASE-ubuntu20.04/usr/bin/swiftc')))
    if op == 'Build':
        exe_flags = ['']
    elif op == 'Check':
        exe_flags = ['-typecheck']
    else:
        return None
    if exe:
        version = sp.run([exe, '--version'], stdout=sp.PIPE).stdout.decode('utf-8').split()[2]
        compile_file(code_paths,
                     out_flag_and_exe=['-o', out_binary(lang)],
                     exe=exe,
                     runner=True,
                     exe_flags=exe_flags,
                     args=args,
                     op=op,
                     compiler_version=version,
                     lang=lang,
                     templated=templated,
                     results=results)


def bench_OCaml(results, code_paths, args, op, templated, bytecode):
    lang = 'OCaml'
    if bytecode:
        exe = match_lang_exe(args, lang, 'ocamlc')
    else:
        exe = match_lang_exe(args, lang, 'ocamlopt')
    if exe:
        version = sp.run([exe, '--version'], stdout=sp.PIPE).stdout.decode('utf-8').split()[0]
        compile_file(code_paths,
                     out_flag_and_exe=['-o', out_binary(lang)],
                     exe=exe,
                     runner=([which('ocamlrun')] if
                             bytecode else
                             True),
                     exe_flags=['-c'] if bytecode else  ['-linscan'],
                     args=args,
                     op=op,
                     compiler_version=version,
                     lang=lang,
                     templated=templated,
                     results=results)


def bench_V(results, code_paths, args, op, templated):
    lang = 'V'                                   # vlang.io
    exe = match_lang_exe(args, lang, 'v')
    if exe:
        version = sp.run([exe, '--version'], stdout=sp.PIPE).stdout.decode('utf-8').split()[1]
        compile_file(code_paths,
                     out_flag_and_exe=['-o', out_binary(lang)],
                     exe=exe,
                     runner=True,
                     exe_flags=[], # -backend flag fails
                     args=args,
                     op=op,
                     compiler_version=version,
                     lang=lang,
                     templated=templated,
                     results=results)


def bench_C3(results, code_paths, args, op, templated):
    lang = 'C3'
    exe = (match_lang_exe(args, lang, 'c3c') or
           which(os.path.join(HOME, 'ware/c3c/build/c3c')))
    if exe:
        exe_flags = ['-O0']

        if op == 'Check':
            exe_flags += ['compile-only'] + ['-C']
        elif op == 'Compile':
            exe_flags += ['compile-only']
        else:
            exe_flags += ['compile']

        version = sp.run([exe, '--version'], stdout=sp.PIPE).stdout.decode('utf-8').split(':')[1].split()[0]
        compile_file(code_paths,
                     out_flag_and_exe=['-o', out_binary(lang)],
                     exe=exe,
                     runner=True,
                     exe_flags=exe_flags,
                     args=args,
                     op=op,
                     compiler_version=version,
                     lang=lang,
                     templated=templated,
                     results=results)


def bench_Zig(results, code_paths, args, op, templated):
    lang = 'Zig'
    if op == 'Check':
        exe_flags = ['ast-check']
        out_flag_and_exe = []
    elif op == 'Compile':
        exe_flags = ['build-obj', '-fno-llvm', '-fno-lld']
        out_flag_and_exe = []
    elif op == 'Build':
        exe_flags = ['build-exe', '-fno-llvm', '-fno-lld']
        out_flag_and_exe = ['--name', out_binary(lang)]
    else:
        return None
    exe = match_lang_exe(args, lang, 'zig')
    if exe:
        version = sp.run([exe, 'version'], stdout=sp.PIPE).stdout.decode('utf-8').split()[0]
        compile_file(code_paths,
                     out_flag_and_exe=out_flag_and_exe,
                     exe=exe,
                     runner=True,
                     exe_flags=exe_flags,
                     args=args,  # no syntax flag currently so compile to object file instead
                     op=op,
                     compiler_version=version,
                     lang=lang,
                     templated=templated,
                     results=results)


def bench_Mojo(results, code_paths, args, op, templated):
    lang = 'Mojo'
    exe = match_lang_exe(args, lang, 'mojo')
    if exe:
        version = sp.run([exe, '--version'], stdout=sp.PIPE).stdout.decode('utf-8').split()[1]
        compile_file(code_paths,
                     out_flag_and_exe=['-o', out_binary(lang)],
                     exe=exe,
                     runner=True,
                     exe_flags=['build', '-O0'],
                     args=args,  # no syntax flag currently so compile to object file instead
                     op=op,
                     compiler_version=version,
                     lang=lang,
                     templated=templated,
                     results=results)


def bench_Nim(results, code_paths, args, op, templated, exe_flags=None):
    lang = 'Nim'
    exe = match_lang_exe(args, lang, 'nim')

    # tcc_exe = which('tcc')
    # exe_flags = ['--hints:off', '--checks:off', '--stacktrace:off'] + ([('--cc:tcc')] if tcc_exe else [])
    exe_flags = ['--hints:off', '--checks:off', '--stacktrace:off']

    if op == 'Check':
        exe_flags += ['check']
    elif op == 'Build':
        # the bottleneck is clang compilation
        exe_flags += ['c', '--mm:refc', '--opt:none']  # TODO detect when --gc:arc is available
    else:
        return None
    if exe:
        version = sp.run([exe, '--version'], stdout=sp.PIPE).stdout.decode('utf-8').split()[3]
        compile_file(code_paths,
                     out_flag_and_exe=['--out:' + out_binary(lang)],
                     exe=exe,
                     runner=True,
                     exe_flags=exe_flags,
                     args=args,  # no syntax flag currently so compile to object file instead
                     op=op,
                     compiler_version=version,
                     lang=lang,
                     templated=templated,
                     results=results)


def set_rustup_channel(channel):
    with sp.Popen(['rustup', 'default', channel],
                  stdout=sp.PIPE,
                  stderr=sp.PIPE) as proc:
        proc.communicate()


def rust_flags(channel):
    flags = RUSTC_FLAGS
    if channel == 'nightly':
        process = sp.Popen('rustc -Z help', shell=True, stdout=sp.PIPE)
        output, error = process.communicate()
        if 'threads=val' in output.decode('utf-8'):
            flags += RUSTC_NIGHTLY_FLAGS
    return flags


def bench_Rust(results, code_paths, args, op, templated):
    lang = 'Rust'

    rustup_exe = which('rustup')
    if rustup_exe:
        rustup_channels = ['stable', 'nightly']
    else:
        rustup_channels = [None]

    try:
        exes = args.language_exes[lang]
    except KeyError:
        return
    if not exes:
        exes = LANGUAGE_EXES[lang]

    for channel in rustup_channels:
        if rustup_exe is not None:
            set_rustup_channel(channel)

        for exe in exes:
            version = sp.run([exe, '--version'], stdout=sp.PIPE).stdout.decode('utf-8').split()[1]
            if op == 'Check':
                # `cargo check` uses `rustc --emit=metadata`
                check_args = ['--emit=metadata']
                out_flag_and_exe = []
            elif op == 'Build':
                out_flag_and_exe = ['-o', out_binary(lang)]
            else:
                continue
            exe_flags = ([] if op == 'Build' else check_args) + rust_flags(channel)
            compile_file(code_paths,
                         out_flag_and_exe=out_flag_and_exe,
                         exe=exe,
                         runner=True,
                         exe_flags=exe_flags,  # https://github.com/rust-lang/rfcs/issues/1476
                         args=args,
                         op=op,
                         compiler_version=version,
                         lang=lang,
                         templated=templated,
                         results=results)

def bench_Java(results, code_paths, args, op, templated):
    lang = 'Java'
    exe = match_lang_exe(args, lang, 'javac')
    if exe:
        try:
            task = sp.run([exe, '-version'],
                          stdout=sp.PIPE,
                          stderr=sp.PIPE)
            version = (task.stdout or task.stderr).decode('utf-8').split()[1]
        except Exception:
            print("WARNING: Failed to decode version from neither stdout:" + str(task.stdout) + " nor stderr:" + str(task.stderr) +
                  " of command " + str([exe, '-version']) + ", defaulting version of " + lang + " to `none`",
                  file=sys.stderr)
            version = 'unknown'
        compile_file(code_paths,
                     out_flag_and_exe=[],
                     exe=exe,
                     runner=[which('java'), '-classpath', '.'],
                     exe_flags=['-Xdiags:verbose'],
                     args=args,
                     op=op,
                     compiler_version=version,
                     lang=lang,
                     templated=templated,
                     results=results)

def bench_Pareas(results, code_paths, args, op, templated):
    lang = 'Pareas'
    exe = match_lang_exe(args, lang, 'pareas')
    if exe:
        compile_file(code_paths,
                     out_flag_and_exe=['-o', out_binary(lang)],
                     exe=exe,
                     runner=False,
                     exe_flags=['--check'] if op == 'Check' else [],
                     args=args,
                     op=op,
                     compiler_version='unknown',
                     lang=lang,
                     templated=templated,
                     results=results)


def bench_Julia(results, code_paths, args, op, templated):
    lang = 'Julia'
    exe = match_lang_exe(args, lang, 'julia')
    if exe:
        version = sp.run([exe, '--version'], stdout=sp.PIPE).stdout.decode('utf-8').split()[2]
        compile_file(code_paths,
                     out_flag_and_exe=[],
                     exe=exe,
                     runner=False,
                     exe_flags=JULIA_INTERPRET_FLAGS,  # TODO: use JULIA_COMPILE_FLAGS aswell
                     args=args,
                     op=op,
                     compiler_version=version,
                     lang=lang,
                     templated=templated,
                     results=results)


def compile_file(code_paths,
                 out_flag_and_exe,
                 exe,
                 runner,
                 exe_flags,
                 args,
                 op='Check',
                 compiler_version=None,
                 lang=None,
                 templated=None,
                 results=None):
    key = (lang, templated, exe)

    if key not in results:
        row = [None] * TABLE_LENGTH  # preallocate
        results[key] = row
    else:
        row = results[key]

    # op
    durs = []                  # compilation durations
    rss_mu = None                    # RSS memory usage
    for run_ix in range(0, args.run_count):
        src_key = sourceIdOf(lang, templated, run_ix)

        if src_key in code_paths:
            src_path = code_paths[src_key]  # retrieve from cache
        else:
            src_path = generate_test_program_file(lang, args, templated, run_ix)  # generate
            code_paths[src_key] = src_path  # store in cache
        src_name = os.path.basename(src_path)

        cstart = timer()        # compilation start
        p_args = [exe] + exe_flags + out_flag_and_exe + [src_name]
        cwd = os.getcwd()
        os.chdir(out_directory(lang))
        pt = ProcessTimer(args=p_args)
        try:
            while pt.poll():
                time.sleep(1.0 / args.sample_rate)  # poll as often as possible
        except Exception:
            # if rss_mu is None and pt.max_rss_mu != 0:
            #     rss_mu = pt.max_rss_mu
            # if rss_mu is None:
            #     rss_mu = "unavailable"
            rss_mu = "sampling error"  # precision of maximum is uncertain
        finally:
            if rss_mu is None and pt.max_rss_mu != 0:
                rss_mu = pt.max_rss_mu
            if rss_mu is None:
                rss_mu = "sampling miss"
        # TODO pt.assertClosed() needed?
        outs, errs = pt.comp_proc.communicate()
        os.chdir(cwd)           # restore

        # print('Compilation:', ' '.join([exe] + exe_flags + out_flag_and_exe + src_name))
        if pt.comp_proc.returncode != 0:
            print("WARNING: Compilation `" + ' '.join([exe] + exe_flags) +
                  "` of source file `" + src_name +
                  "` exited with return code " + str(pt.comp_proc.returncode) +
                  ("`\n  - stdout:\n" + str(outs) if outs else "") +
                  ("`\n  - stderr:\n" + errs.decode('utf8') if errs else ""),
                  file=sys.stderr)
            if rss_mu and isinstance(rss_mu, (int, float)):
                if op == "Check":
                    row[CHECK_RSS_MU_IX] = rss_mu / (args.function_count * args.function_depth)
                if op == "Build":
                    row[BUILD_RSS_MU_IX] = rss_mu / (args.function_count * args.function_depth)
            return None

        durs.append(timer() - cstart)

        if outs:
            if not outs.startswith(b'/usr/bin/ld: warning'):
                print('stdout:', outs)
        if errs:
            if lang == 'Ada':
                errs = errs.lstrip(b'x86_64-linux-gnu-gcc-10 -c -Igenerated/ada/ -I- generated/ada/main.adb\n')
            if len(errs) and not errs.startswith(b'/usr/bin/ld: warning'):  # skip ld warning
                print('output:', errs)
    dur_min = min(durs)         # duration minimum

    # run
    run_dur_min = None             # run duration minimum
    if op == 'Build':
        outb = out_binary(lang)
        if runner:
            if runner is True:      # binary should be runnable
                if (exe.endswith('cproc')):  # cproc forgets to set executable bit
                    st = os.stat(exe)
                    os.chmod(outb, st.st_mode | stat.S_IEXEC)
                run_dur_min = run_compiled_file(exe)
            elif isinstance(runner, list):
                run_dur_min = run_compiled_file(runner + [outb])
        elif out_flag_and_exe:
            if runner is not False:
                print("TODO run " + outb + " using runner " + str(runner))

    show_file = False
    compiler_version_str = ' version ' + str(compiler_version) if compiler_version is not None else ''
    if show_file:
        print('- {} of {} took {:1.3f} seconds (using "{}"{})'.format(op, src_name, dur_min, exe,
                                                                      compiler_version_str))
    else:
        print('- {} took {:1.3f} seconds (using "{}"{})'.format(op, dur_min, exe,
                                                                compiler_version_str))

    table_row(row=row,
              args=args,
              lang=lang,
              op=op,
              exe_path=exe,
              compiler_version=compiler_version,
              check_dur=dur_min if op == 'Check' else None,
              compile_dur=dur_min if op == 'Compile' else None,
              build_dur=dur_min if op == 'Build' else None,
              run_dur=run_dur_min,
              check_rss_mu=rss_mu if op == 'Check' else None,
              build_rss_mu=rss_mu if op == 'Build' else None,
              templated=templated)


def run_compiled_file(args, run_count=1):
    durs = []                  # compilation durations
    for _ in range(0, run_count):
        cstart = timer()        # compilation start
        # print("args:", args)
        with sp.Popen(args,
                      stdout=sp.PIPE,
                      stderr=sp.PIPE) as comp_proc:
            outs, errs = comp_proc.communicate()
            # pprint(comp_proc.__dict__)
            # TODO detect segfault exit code
            # if comp_proc.returncode != 0:
            #     print("WARNING: Run of compiled exec `" + str(args) +
            #           "` exited with return code " + str(comp_proc.returncode),
            #           file=sys.stderr)
            #     return None
            durs.append(timer() - cstart)
    dur_min = min(durs)         # running duration minimum
    return dur_min


def long_types_of_lang(lang):
    if lang in ('c', 'c3', 'c++', 'c#', 'java'):
        return ['long']
    elif lang in ('rust', 'zig', 'v', 'vox', 'c3'):
        return ['i64']
    elif lang in 'swift':
        return ['Int64']
    elif lang == 'd':
        return ['long']
    elif lang in ('go', 'nim'):
        return ['int64']
    elif lang == 'julia':
        return ['Int64']
    elif lang == 'ocaml':
        return ['float']
    elif lang == 'ada':
        return ['Long_Integer']  # gnat
    elif lang == 'pareas':
        return ['int']
    elif lang == 'mojo':
        return ['Int']
    else:
        return None


def language_file_extension(lang):
    if lang == 'rust':
        return 'rs'
    elif lang == 'julia':
        return 'jl'
    elif lang == 'ocaml':
        return 'ml'
    elif lang == 'c#':
        return 'cs'
    elif lang == 'vox':
        return 'vx'
    elif lang == 'ada':
        return 'adb'
    elif lang == 'pareas':
        return 'par'
    else:
        return lang


def generate_test_program_file(lang, args, templated, run_ix):
    program_name = DEFAULT_PROGRAM_NAME

    llang = lang.lower()        # lowered language
    types = long_types_of_lang(llang)
    ext = language_file_extension(llang)
    dir_path = os.path.join(ROOT_PATH, llang)
    os.makedirs(dir_path, exist_ok=True)

    path = (os.path.join(dir_path, program_name + ('_t' if templated else '') +
                         ('_' + str(run_ix) if lang.lower() != 'ada' else '') +
                         '.' + ext))

    start = timer()
    with open(path, 'w') as f:
        generate_test_language_specific_prefix(llang, program_name, f, templated=templated)

        if llang == 'ada':
            generate_test_main_header(llang, types, f, templated)
            generate_main_test_function_definition_set(llang, types, args, f,
                                                       templated=templated)
        else:
            generate_main_test_function_definition_set(llang, types, args, f,
                                                       templated=templated)
            generate_test_main_header(llang, types, f, templated)

        for typ in types:
            generate_main_test_function_variable(llang, typ, f, templated=templated)

        generate_test_main_middle(llang, types, f, templated)

        for typ in types:
            for findex in range(0, args.function_count):
                generate_test_function_call(llang, findex, typ, f, templated=templated)

        generate_test_language_specific_postfix(llang, types, f)
    end = timer()
    dur = (end - start)  # time dur
    print('- Generating {} took {:1.3f} seconds ({})'.format(path, dur, lang))

    return path


def generate_test_function_call(lang, findex, typ, f, templated):
    if lang in ('c#', 'java'):
        f.write('    ')

    if lang == 'zig' and templated:  # Zig needs explicit template type
        f.write(Tm('    ${T}_sum += add_${T}_n${N}(${T}, ${N})').substitute(T=typ, N=str(findex)))
    elif lang == 'v' and templated:  # Zig needs explicit template type for now. See: https://github.com/vlang/v/issues/5818
        f.write(Tm('    ${T}_sum += add_${T}_n${N}<${T}>(${N})').substitute(T=typ, N=str(findex)))
    elif lang == 'ocaml':
        f.write(Tm('    let ${T}_sum = ${T}_sum +. (add_${T}_n${N} ${N}.0) in').substitute(T=typ, N=str(findex)))
    elif lang == 'ada':
        f.write(Tm('   ${T}_sum := ${T}_sum + add_${T}_n${N}(${N})').substitute(T=typ, N=str(findex)))
    elif lang == 'vox':
        f.write(Tm('    ${T}_sum += add_${T}_n${N}${X}(${N})').substitute(T=typ,
                                                                          N=str(findex),
                                                                          X='[' + typ + ']' if templated else ''))
    elif lang == 'swift':
        f.write(Tm('    ${T}_sum += add_${T}_n${N}(x: ${N})').substitute(T=typ, N=str(findex)))
    elif lang == 'pareas':
        f.write(Tm('    ${T}_sum = ${T}_sum + add_${T}_n${N}[${N}]').substitute(T=typ, N=str(findex)))
    elif lang == 'mojo':
        f.write(Tm('    ${T}_sum = ${T}_sum + add_${T}_n${N}(${N})').substitute(T=typ, N=str(findex)))
    else:
        f.write(Tm('    ${T}_sum += add_${T}_n${N}(${N})').substitute(T=typ, N=str(findex)))

    if lang not in ('ocaml', 'nim', 'v'):
        f.write(';')            # statement terminator

    f.write('\n')


def generate_test_language_specific_prefix(lang, program_name, f, templated):
    if lang == 'go':
        f.write('package ' + program_name + ';\n')
        f.write('// import ("os")\n\n')  # fails with `gotype`
    elif lang == 'rust':
        f.write('use std::process::exit;\n')
        if templated:
            f.write('use std::ops::Add;\n')
    elif lang == 'swift':
        f.write('import Foundation\n\n')
    elif lang == 'c#':
        f.write('using System;\n\n')
        f.write('public class HelloWorld {\n')
    elif lang == 'java':
        f.write('class HelloWorld {\n')
    elif lang == 'ada':
        f.write('with System;\n\n')
        f.write('with GNAT.OS_Lib;\n\n')
    elif lang == 'vox':
        f.write('''enum u32 stdin = 0;
enum u32 stdout = 1;
enum u32 stderr = 2;

@extern(syscall, 60)
void exit(i32 error_code);

@extern(syscall, 1)
void sys_write(u32 fd, u8* buf, u64 count);

void write(u32 fd, u8[] data) {
	sys_write(fd, data.ptr, data.length);
}
''')


def generate_test_language_specific_postfix(lang, types, f):
    if lang == 'rust':
        f.write(Tm('    exit((${T}_sum % 4294967296) as i32);\n}\n').substitute(T=types[0]))
    elif lang == 'd':
        f.write(Tm('    return cast(int)${T}_sum;\n}\n').substitute(T=types[0]))
    elif lang == 'nim':
        f.write(Tm('    quit(int(${T}_sum))\n\n').substitute(T=types[0]))
    elif lang == 'swift':
        f.write(Tm('    exit(Int32(${T}_sum))\n}\n').substitute(T=types[0]))
    elif lang == 'go':
        f.write(Tm('    // os.Exit(int(${T}_sum));\n').substitute(T=types[0]))
        f.write(Tm('}\n').substitute(T=types[0]))
    elif lang == 'c#':
        f.write(Tm('        Environment.Exit(${T}_sum == 42 ? 1 : 0);\n    }\n').substitute(T=types[0]))
    elif lang == 'java':
        f.write(Tm('        System.exit(${T}_sum == 42 ? 1 : 0);\n    }\n').substitute(T=types[0]))
    elif lang == 'zig':
        f.write(Tm('\n}\n').substitute(T=types[0]))
    elif lang == 'nim':
        f.write(Tm('\n\n').substitute(T=types[0]))
    elif lang == 'c3':
        f.write(Tm('        return (int)(${T}_sum);\n}\n').substitute(T=types[0]))
    elif lang == 'pareas':
        f.write(Tm('    return ${T}_sum;\n}\n').substitute(T=types[0]))
    elif lang == 'mojo':
        f.write(Tm('    print(${T}_sum)\n').substitute(T=types[0]))
    elif lang == 'julia':
        f.write(Tm('''    return ${T}_sum;
end

main()
''').substitute(T=types[0]))
    elif lang == 'd':
        f.write(Tm('''    return cast(int)${T}_sum;
}
''').substitute(T=types[0]))
    elif lang == 'vox':
        # TODO: use exit(i32(${T}_sum)) when it doesnâ€™t segfault:
        f.write(Tm('''    exit(0);
    return 0;
}
''').substitute(T=types[0]))
    elif lang == 'ada':
        f.write(Tm('''   GNAT.OS_Lib.OS_Exit(Integer(${T}_sum));
end Main;
''').substitute(T=types[0]))
    elif lang == 'ocaml':
        f.write(Tm('    exit (if ${T}_sum = 42.0 then 1 else 0)\n').substitute(T=types[0]))
    elif lang == 'v':
        f.write(Tm('''    exit(int(${T}_sum >> 32))\n}\n''').substitute(T=types[0]))
    else:
        f.write(Tm('''    return ${T}_sum;\n}\n''').substitute(T=types[0]))

    if lang in ('c#', 'java'):
        f.write('}\n')            # one extra closing brace for class


def generate_main_test_function_definition_set(lang, types, args, f,
                                               templated):
    for typ in types:
        for findex in range(0, args.function_count):
            for fheight in range(0, args.function_depth):
                generate_test_function_definition(args, lang, typ, findex, fheight, f,
                                                  templated=templated)
            f.write('\n')
        f.write('\n')


def function_name(typ, findex, fheight):
    if fheight is not None:
        return Tm('add_${T}_n${N}_h${H}').substitute(T=typ,
                                                     N=str(findex),
                                                     H=str(fheight))
    else:
        return Tm('add_${T}_n${N}').substitute(T=typ,
                                               N=str(findex))


def generate_test_function_definition(args, lang, typ, findex, fheight, f,
                                      templated):
    if RANDOMIZE_FLAG:
        nconst = str(random.randint(0, 100000))
    else:
        nconst = str(findex)

    if fheight == 0:
        if lang == 'rust' and templated:
            expr = 'x'          # because Rust is picky
        elif lang == 'ocaml':
            expr = 'x +. ' + nconst + '.0'
        else:
            expr = 'x + ' + nconst
    else:
        if lang == 'zig' and templated:
            xtarg = typ + ', '  # Zig needs explicit template parameter
        else:
            xtarg = ''
        if lang == 'rust' and templated:
            call = function_name(typ, findex, fheight - 1) + '(' + xtarg + 'x)'
            expr = 'x + ' + call
        elif lang == 'v' and templated:
            call = function_name(typ, findex, fheight - 1) + Tm('<${T}>(x)').substitute(T=typ)
            expr = 'x + ' + call
        elif lang == 'vox' and templated:
            call = function_name(typ, findex, fheight - 1) + Tm('[${T}](x)').substitute(T=typ)
            expr = 'x + ' + call
        elif lang == 'ocaml':
            expr = 'x +. (' + function_name(typ, findex, fheight - 1) + xtarg + ' x) +. ' + nconst + '.0'
        elif lang == 'swift':
            expr = 'x + ' + function_name(typ, findex, fheight - 1) + '(x: ' + xtarg + 'x) + ' + nconst
        elif lang == 'pareas':
            expr = 'x + ' + function_name(typ, findex, fheight - 1) + '[x] + ' + nconst
        elif lang == 'mojo':
            expr = 'x + ' + function_name(typ, findex, fheight - 1) + '(x) + ' + nconst # TODO: Add xtarg
        else:
            expr = 'x + ' + function_name(typ, findex, fheight - 1) + '(' + xtarg + 'x) + ' + nconst

    if fheight == args.function_depth - 1:
        fname = function_name(typ, findex, fheight=None)
    else:
        fname = function_name(typ, findex, fheight)

    if lang in ('c'):
        f.write(Tm('${T} ${F}(${T} x) { return ${X}; }\n').substitute(T=typ, F=str(fname), N=nconst, X=expr))
    elif lang in ('c3'):
        f.write(Tm('fn ${T} ${F}(${T} x) { return ${X}; }\n').substitute(T=typ, F=str(fname), N=nconst, X=expr))
    elif lang in ['ada']:
        f.write(Tm('''   function ${F} (x: ${T}) return ${T} is (${X});
''').substitute(T=typ, F=str(fname), N=nconst, X=expr))
    elif lang in ['c#']:
        f.write(Tm('    static ${T} ${F}(${T} x) { return ${X}; }\n').substitute(T=typ, F=str(fname), N=nconst, H=str(fheight), X=expr))
    elif lang in ['java']:
        f.write(Tm('    static ${T} ${F}(${T} x) { return ${X}; }\n').substitute(T=typ, F=str(fname), N=nconst, H=str(fheight), X=expr))
    elif lang in ['c++']:
        f.write(Tm('${M}${T} ${F}(${T} x) { return ${X}; }\n')
                .substitute(T=typ, F=str(fname), N=nconst, H=str(fheight),
                            M='template<typename T=int> ' if templated else '',
                            X=expr))
        # template<typename T1, typename T2 = int> class A;
    elif lang in ('d', 'vox'):
        # See: https://forum.dlang.org/post/sfldpxiieahuiizvgjeb@forum.dlang.org
        f.write(Tm('${T} ${F}${M}(${T} x)${Q} { return ${X}; }\n')
                .substitute(T='T' if templated else typ,
                            F=str(fname),
                            N=nconst,
                            H=str(fheight),
                            M=('(T)' if lang == 'd' else '[T]') if templated else '',
                            Q=' @safe pure nothrow @nogc' if lang == 'd' else '',
                            X=expr))
    elif lang == 'rust':
        if templated:
            f.write(Tm('fn ${F}<${T} : ${R}>(x: ${T}) -> ${T} { ${X} }\n').substitute(T='T',
                                                                                      R='Copy + Add<Output = T>',
                                                                                      F=str(fname),
                                                                                      N=nconst,
                                                                                      H=str(fheight),
                                                                                      X=expr))
        else:
            f.write(Tm('fn ${F}(x: ${T}) -> ${T} { ${X} }\n').substitute(T=typ, F=str(fname), N=nconst, H=str(fheight), X=expr))
    elif lang == 'swift':
        if templated:
            f.write(Tm('func ${F}<${T}>(x: ${T}) -> ${T} { return ${X} }\n').substitute(T='T',
                                                                                        F=str(fname),
                                                                                        N=nconst,
                                                                                        H=str(fheight),
                                                                                        X=expr))
        else:
            f.write(Tm('func ${F}(x: ${T}) -> ${T} { return ${X} }\n').substitute(T=typ, F=str(fname), N=nconst, H=str(fheight), X=expr))
    elif lang == 'nim':
        if templated:
            f.write(Tm('proc ${F}<${T}>(x: ${T}): ${T} =\n  return ${X}\n').substitute(T='T',
                                                                                       F=str(fname),
                                                                                       N=nconst,
                                                                                       H=str(fheight),
                                                                                       X=expr))
        else:
            f.write(Tm('proc ${F}(x: ${T}): ${T} = \n  return ${X}\n').substitute(T=typ, F=str(fname), N=nconst, H=str(fheight), X=expr))
    elif lang == 'c3':
        if templated:
            f.write(Tm('fn ${F}<${T}>(x: ${T}) -> ${T} { return ${X} }\n').substitute(T='T',
                                                                                        F=str(fname),
                                                                                        N=nconst,
                                                                                        H=str(fheight),
                                                                                        X=expr))
        else:
            f.write(Tm('fn ${T} ${F}(${T} x) { return ${X} }\n').substitute(T=typ, F=str(fname), N=nconst, H=str(fheight), X=expr))
    elif lang == 'zig':
        if templated:
            f.write(Tm('fn ${F}(comptime T: type, x: T) T { return ${X}; }\n').substitute(T=typ, F=str(fname), N=nconst, H=str(fheight), X=expr))
        else:
            f.write(Tm('fn ${F}(x: ${T}) ${T} { return ${X}; }\n').substitute(T=typ, F=str(fname), N=nconst, H=str(fheight), X=expr))
    elif lang == 'go':
        f.write(Tm('func ${F}(x ${T}) ${T} { return ${X} }\n').substitute(T=typ, F=str(fname), N=nconst, H=str(fheight), X=expr))
    elif lang == 'ocaml':
        f.write(Tm('let ${F} x = ${X}\n').substitute(F=str(fname), X=expr))
    elif lang == 'v':
        if templated:
            f.write(Tm('fn ${F}<${T}>(x ${T}) ${T} { return ${X} }\n').substitute(T='T', F=str(fname), N=nconst, H=str(fheight), X=expr))
        else:
            f.write(Tm('fn ${F}(x ${T}) ${T} { return ${X} }\n').substitute(T=typ, F=str(fname), N=nconst, H=str(fheight), X=expr))
    elif lang == 'julia':
        f.write(Tm('function ${F}(x${QT})${QT}\n    return ${X}\nend;\n').substitute(QT=('' if templated else ('::' + typ)),
                                                                                     F=str(fname), N=nconst, H=str(fheight), X=expr))
    elif lang == 'pareas':
        f.write(Tm('fn ${F}[x: ${T}]: ${T} { return ${X}; }\n').substitute(T=typ, F=str(fname), X=expr))
    elif lang == 'mojo':
        f.write(Tm('fn ${F}(x: ${T}) -> ${T}: return ${X}\n').substitute(T=typ, F=str(fname), X=expr))


def generate_test_main_header(lang, types, f, templated):
    if lang in ['c', 'c++']:
        # `cproc` cannot handle this skip for now:
        # f.write('int main(__attribute__((unused)) int argc, __attribute__((unused)) char* argv[]) {\n')
        f.write('int main(void) {\n')
    elif lang == 'ada':
        f.write('procedure Main is\n')
    elif lang == 'c#':
        f.write('    public static void Main(string[] args) {\n')
    elif lang == 'java':
        f.write('    public static void main(String args[]) {\n')
    elif lang == 'd':
        f.write('int main() @safe {\n')
    elif lang == 'vox':
        f.write('i32 main() {\n')
    elif lang == 'rust':
        f.write(Tm('fn main() {\n').substitute(T=types[0]))
    elif lang == 'swift':
        f.write(Tm('func main() {\n').substitute(T=types[0]))
    elif lang == 'zig':
        f.write(Tm('pub fn main() void {\n').substitute(T=types[0]))
    elif lang == 'c3':
        f.write(Tm('fn int main() {\n').substitute(T=types[0]))
    elif lang == 'go':
        f.write(Tm('func main() {\n').substitute(T=types[0]))
    elif lang == 'v':
        f.write(Tm('fn main() {\n').substitute(T=types[0]))
    elif lang == 'julia':
        f.write(Tm('function main()${QT}\n').substitute(QT=(('::' + types[0]) if templated else '')))
    elif lang == 'ocaml':
        f.write('let () = \n')
    elif lang == 'nim':
        f.write('when isMainModule:\n')
    elif lang == 'pareas':
        f.write('fn main[]: int {\n')
    elif lang == 'mojo':
        f.write('fn main() -> None:\n')
    else:
        assert False


def generate_test_main_middle(lang, types, f, templated):
    if lang == 'ada':
        f.write('begin\n')


def generate_main_test_function_variable(lang, typ, f, templated):
    if lang in ('c', 'c3', 'c++', 'd', 'vox'):
        f.write(Tm('    ${T} ${T}_sum = 0;\n').substitute(T=typ))
    elif lang in ['ada']:
        f.write(Tm('   ${T}_sum : ${T} := 0;\n').substitute(T=typ))
    elif lang in ['c#']:
        f.write(Tm('        ${T} ${T}_sum = 0;\n').substitute(T=typ))
    elif lang in ['java']:
        f.write(Tm('        ${T} ${T}_sum = 0;\n').substitute(T=typ))
    elif lang == 'rust':
        f.write(Tm('    let mut ${T}_sum : ${T} = 0;\n').substitute(T=typ))
    elif lang == 'swift':
        f.write(Tm('    var ${T}_sum: ${T} = 0;\n').substitute(T=typ))
    elif lang == 'nim':
        f.write(Tm('    var ${T}_sum: ${T} = 0;\n').substitute(T=typ))
    elif lang == 'zig':
        f.write(Tm('    var ${T}_sum: ${T} = 0;\n').substitute(T=typ))
    elif lang == 'go':
        f.write(Tm('    var ${T}_sum ${T} = 0;\n').substitute(T=typ))
    elif lang == 'v':
        f.write(Tm('    mut ${T}_sum := ${T}(0)\n').substitute(T=typ))
    elif lang == 'julia':
        f.write(Tm('    ${T}_sum${QT} = 0;\n').substitute(T=typ, QT=(('::' + typ) if templated else '')))
    elif lang == 'ocaml':
        f.write(Tm('    let ${T}_sum = 0.0 in\n').substitute(T=typ))
    elif lang == 'pareas':
        f.write(Tm('    var ${T}_sum: ${T} = 0;\n').substitute(T=typ))
    elif lang == 'mojo':
        f.write(Tm('    var ${T}_sum: ${T} = 0\n').substitute(T=typ))
    else:
        assert False


def generate_test_program_2(function_count, lang, templated):
    program_name = 'sample2'

    lang = lang.lower()
    types = long_types_of_lang(lang)
    ext = language_file_extension(lang)
    dir_path = os.path.join(ROOT_PATH, lang)
    os.makedirs(dir_path, exist_ok=True)
    path = os.path.join(dir_path, program_name + '.' + ext)

    start = timer()
    with open(path, 'w') as f:

        # package definition
        if lang == 'go':
            f.write('''package ''' + program_name + ''';

''')

        # standard io module
        if lang in ['c']:
            f.write('''#include <stdio.h>
''')
        if lang in ['c++']:
            f.write('''#include <iostream>
''')
        if lang in ('d', 'vox'):
            f.write('''import std.stdio;
''')
        if lang == 'rust':
            f.write('''use std::io;
''')
        if lang == 'c3':
            f.write('''import std::io;
''')
        if lang == 'go':
            f.write('''import "fmt";

''')
        if lang == 'v':
            f.write('''import os
''')

        # special modules
        if lang == 'rust':
            f.write('''use std::process::exit;
''')

        for typ in types:
            for findex in range(0, function_count):
                if lang in ('c', 'c++'):
                    f.write(Tm('''${T} add_${T}_n${N}(${T} x) { return x + ${N}; }
''').substitute(T=typ, N=str(findex)))
                if lang in ('d', 'vox'):
                    f.write(Tm('''${T} add_${T}_n${N}(${T} x) pure { return x + ${N}; }
''').substitute(T=typ, N=str(findex)))
                elif lang == 'c3':
                    f.write(Tm('''fn ${T} add_${T}_n${N}(${T} x) { return x + ${N}; }
''').substitute(T=typ, N=str(findex)))
                elif lang == 'rust':
                    f.write(Tm('''fn add_${T}_n${N}(x: ${T}) -> ${T} { x + ${N} }
''').substitute(T=typ, N=str(findex)))
                elif lang == 'zig':
                    f.write(Tm('''fn add_${T}_n${N}(x: ${T}) ${T} { return x + ${N}; }
''').substitute(T=typ, N=str(findex)))
                elif lang == 'go':
                    f.write(Tm('''func add_${T}_n${N}(x ${T}) ${T} { return x + ${N} }
''').substitute(T=typ, N=str(findex)))
                elif lang == 'ocaml':
                    f.write(Tm('''let add_${T}_n${N} x = x +. ${N}.0
''').substitute(T=typ, N=str(findex)))
                elif lang == 'v':
                    f.write(Tm('''fn add_${T}_n${N}(x ${T}) ${T} { return x + ${N} }
''').substitute(T=typ, N=str(findex)))
                elif lang == 'julia':
                    f.write(Tm('''function add_${T}_n${N}(x${QT})${QT}
    return x + ${N}
end;
''').substitute(QT=('' if templated else ('::' + typ)), N=str(findex)))
                    f.write('\n')
                elif lang == 'pareas':
                    f.write(Tm('fn add_${T}_n${N}[x: ${T}]: ${T} { return x + ${N}; }').substitute(T=typ, N=str(findex)))
                elif lang == 'mojo':
                    f.write(Tm('fn add_${T}_n${N}(x: ${T}) -> ${T}: return x + ${N}').substitute(T=typ, N=str(findex)))

        # MAIN HEADER
        if lang in ['c', 'c++']:
            f.write('''int main(__attribute__((unused)) int argc, __attribute__((unused)) char* argv[])
{
''')
        elif lang in ('d', 'vox'):
            f.write('''int main(string[] args)
{
''')
        elif lang == 'rust':
            f.write(Tm('''fn main() {
''').substitute(T=types[0]))
        elif lang == 'zig':
            f.write(Tm('''pub fn main() void {
''').substitute(T=types[0]))
        elif lang == 'go':
            f.write(Tm('''func main() ${T} {
''').substitute(T=types[0]))
        elif lang == 'v':
            f.write(Tm('''fn main() ${T} {
''').substitute(T=types[0]))
        elif lang == 'julia':
            f.write(Tm('''function main()::${T}
''').substitute(T=types[0]))
        elif lang == 'pareas':
            f.write(Tm('fn main[]: ${T} {\n').substitute(T=types[0]))
        elif lang == 'mojo':
            f.write(Tm('fn main():\n').substitute(T=types[0]))
        else:
            assert False

        # CALCULATE
        for typ in types:
            if lang in ('c', 'c3', 'c++', 'd', 'vox'):
                f.write(Tm('''    ${T} ${T}_sum = 0;
''').substitute(T=typ))
            elif lang == 'rust':
                f.write(Tm('''    let mut ${T}_sum : ${T} = 0;
''').substitute(T=typ))
            elif lang == 'zig':
                f.write(Tm('''    var ${T}_sum: ${T} = 0;
''').substitute(T=typ))
            elif lang == 'go':
                f.write(Tm('''    var ${T}_sum ${T} = 0;
''').substitute(T=typ))
            elif lang == 'v':
                f.write(Tm('''    var ${T}_sum ${T} = 0;
''').substitute(T=typ))
            elif lang == 'julia':
                f.write(Tm('''    ${T}_sum${QT} = 0;
''').substitute(QT=('' if templated else ('::' + typ))))
            elif lang == 'pareas':
                f.write(Tm('    var ${T}_sum: ${T} = 0;\n').substitute(T=typ))
            else:
                assert False

            if lang == 'pareas':
                f.write(Tm('    ${T}_sum += add_${T}_n${N}[${N}];').substitute(T=typ, N=str(findex)))
            if lang == 'mojo':
                f.write(Tm('    ${T}_sum += add_${T}_n${N}(${N})').substitute(T=typ, N=str(findex)))
            else:
                for findex in range(0, function_count):
                    f.write(Tm('''    ${T}_sum += add_${T}_n${N}(${N});
''').substitute(T=typ, N=str(findex)))

        if lang == 'rust':
            f.write(Tm('''    exit(${T}_sum);
}
''').substitute(T=types[0]))
        elif lang == 'zig':
            f.write(Tm('''
}
''').substitute(T=types[0]))
        elif lang == 'ocaml':
            f.write(Tm('''    ${T}_sum''').substitute(T=types[0]))
        elif lang == 'julia':
            f.write(Tm('''    return ${T}_sum;
end

main()
''').substitute(T=types[0]))
        elif lang in ('d', 'vox'):
            f.write(Tm('''    return cast(int)${T}_sum;
}
''').substitute(T=types[0]))
        else:
            f.write(Tm('''    return ${T}_sum;
}
''').substitute(T=types[0]))

    end = timer()
    dur = (end - start)  # time dur
    print('- Generating {} took {:1.3f} seconds ({})'.format(path, dur, lang))

    return path


def main():
    parser = argparse.ArgumentParser(formatter_class=argparse.ArgumentDefaultsHelpFormatter)

    parser.add_argument('--languages', '--langs', type=str,
                        default=','.join(LANGUAGE_EXES.keys()),
                        help='Languages (optionally combined with compilers) to benchmark separated by comma. For instance --languages=C:tcc,D:dmd,D:gdc,D:ldmd2.')

    parser.add_argument('--operations', '--ops', type=str,
                        default=','.join(SUPPORTED_OPERATIONS),
                        help='Operations to perform separated by comma')

    parser.add_argument('--function-count', '--fc', type=int,
                        default=200,
                        help='Number of functions generated and called')

    parser.add_argument('--function-depth', '--fd', type=int,
                        default=200,
                        help='Function call depth')

    parser.add_argument('--sample-rate', '--sr', type=int,
                        default=100,
                        help='Rate of memory usage sampling. Unit is samples per second.')

    parser.add_argument('--run-count', '--rc', type=int,
                        default=5,
                        help='Number of runs for each compilation')

    args = parser.parse_args()
    install_missing_modules()

    args.languages = list(map(lambda x: 'OCaml' if x.lower() == 'ocaml' else x.capitalize(),
                              args.languages.split(',')))  # into a list
    args.language_exes = {}
    for language_exes_spec in args.languages:
        split = language_exes_spec.split(':')
        if len(split) == 2:
            language = split[0]
            exes = split[1]. split(',')
        else:
            language = split[0]
            exes = []
        if language not in LANGUAGE_EXES:
            print('Warning: Ignoring unsupported language ' + language)
            continue
        if language in args.language_exes:
            args.language_exes[language] += exes
        else:
            args.language_exes[language] = exes
    if not args.language_exes:
        args.language_exes = LANGUAGE_EXES

    args.operations = list(map(lambda x: x.capitalize(), args.operations.split(',')))  # into a list of capitalized names
    filtered_operations = []
    for operation in args.operations:
        if operation in SUPPORTED_OPERATIONS:
            filtered_operations.append(operation)
        else:
            print('Warning: Ignoring unsupported operation ' + operation)
    args.operations = filtered_operations

    code_paths = {}
    results = {}            # tuple(LANGUAGE, TEMPLATEFLAG) => list

    print(markdown_header('Benchmark:', 1))

    for op in args.operations:
        if 'Vox' in args.language_exes:
            for templated in (False, True):
                bench_Vox(results=results, code_paths=code_paths, args=args, op=op, templated=templated)
                bench_Vox(results=results, code_paths=code_paths, args=args, op=op, templated=templated)
        if 'D' in args.language_exes:
            for templated in (False, True):
                bench_D(results=results, code_paths=code_paths, args=args, op=op, templated=templated, use_dips=True)
        if 'Zig' in args.language_exes:
            for templated in (False, True):
                bench_Zig(results=results, code_paths=code_paths, args=args, op=op, templated=templated)
        if 'C' in args.language_exes:
            for templated in (False,):
                bench_C_using_tcc(results=results, lang='C', code_paths=code_paths, args=args, op=op, templated=templated)
                bench_C_using_cuik(results=results, lang='C', code_paths=code_paths, args=args, op=op, templated=templated)
                bench_C_using_cproc(results=results, lang='C', code_paths=code_paths, args=args, op=op, templated=templated)
                bench_C_and_Cxx_using_gcc(results=results, lang='C', code_paths=code_paths, args=args, op=op, templated=templated)
                bench_C_and_Cxx_using_clang(results=results, lang='C', code_paths=code_paths, args=args, op=op, templated=templated)
        if 'C++' in args.language_exes:
            for templated in (False, True):
                bench_C_and_Cxx_using_gcc(results=results, lang='C++', code_paths=code_paths, args=args, op=op, templated=templated)
                bench_C_and_Cxx_using_clang(results=results, lang='C++', code_paths=code_paths, args=args, op=op, templated=templated)

    if 'Ada' in args.language_exes:
        # if 'Check' in args.operations:
        #     bench_Ada_using_gcc(results=results,lang='Ada', code_paths=code_paths, args=args, op='Check', templated=False)
        if 'Build' in args.operations:
            bench_Ada_using_gcc(results=results, lang='Ada', code_paths=code_paths, args=args, op='Build', templated=False)

    if 'Go' in args.language_exes:
        if 'Check' in args.operations:
            bench_Go(results=results, code_paths=code_paths, args=args, op='Check', templated=False)
        if 'Build' in args.operations:
            bench_Go(results=results, code_paths=code_paths, args=args, op='Build', templated=False)

    if 'Swift' in args.language_exes:
        if 'Check' in args.operations:
            bench_Swift(results=results, code_paths=code_paths, args=args, op='Check', templated=False)
        if 'Build' in args.operations:
            bench_Swift(results=results, code_paths=code_paths, args=args, op='Build', templated=False)

    if 'V' in args.language_exes:
        if 'Build' in args.operations:
            bench_V(results=results, code_paths=code_paths, args=args, op='Build', templated=False)
            bench_V(results=results, code_paths=code_paths, args=args, op='Build', templated=True)

    if 'C3' in args.language_exes:
        for op in args.operations:
            bench_C3(results=results, code_paths=code_paths, args=args, op=op, templated=False)

    if 'Rust' in args.language_exes:
        if 'Check' in args.operations:
            bench_Rust(results=results, code_paths=code_paths, args=args,
                       op='Check', templated=False)
            bench_Rust(results=results, code_paths=code_paths, args=args,
                       op='Check', templated=True)
        if 'Build' in args.operations:
            bench_Rust(results=results, code_paths=code_paths, args=args,
                       op='Build', templated=False)
            bench_Rust(results=results, code_paths=code_paths, args=args,
                       op='Build', templated=True)

    if 'Nim' in args.language_exes:
        if 'Check' in args.operations:
            bench_Nim(results=results, code_paths=code_paths, args=args,
                      op='Check', templated=False)
        if 'Build' in args.operations:
            bench_Nim(results=results, code_paths=code_paths, args=args,
                      op='Build', templated=False)

    if 'C#' in args.language_exes:
        if 'Build' in args.operations:
            bench_CSharp_using_mono(results=results, code_paths=code_paths,
                                    args=args, op='Build', templated=False)
            bench_CSharp_using_csc(results=results, code_paths=code_paths,
                                   args=args, op='Build', templated=False)

    if 'Java' in args.language_exes:
        if 'Build' in args.operations:
            bench_Java(results=results, code_paths=code_paths, args=args,
                       op='Build', templated=False)

    if 'Pareas' in args.language_exes:
        if 'Check' in args.operations:
            bench_Pareas(results=results, code_paths=code_paths, args=args,
                         op='Check', templated=False)
        if 'Build' in args.operations:
            bench_Pareas(results=results, code_paths=code_paths, args=args,
                         op='Build', templated=False)

    if 'Mojo' in args.language_exes:
        if 'Build' in args.operations:
            bench_Mojo(results=results, code_paths=code_paths, args=args,
                       op='Build', templated=False)

    # Julia and Ocaml take too long otherwise. So let them participate by
    # truncating size because ops/function are measured
    function_count = args.function_count
    function_depth = args.function_depth
    if args.function_count * args.function_depth >= 10000:
        args.function_count = 200
        args.function_depth = 200

    if 'OCaml' in args.language_exes:
        if 'Build' in args.operations:
            bench_OCaml(results=results, code_paths=code_paths, args=args,
                        op='Build', templated=False, bytecode=False)
            bench_OCaml(results=results, code_paths=code_paths, args=args,
                        op='Build', templated=False, bytecode=True)

    if 'Julia' in args.language_exes:
        if 'Build' in args.operations:
            bench_Julia(results=results, code_paths=code_paths, args=args,
                        op='Build', templated=False)
            bench_Julia(results=results, code_paths=code_paths, args=args,
                        op='Build', templated=True)

    args.function_count = function_count
    args.function_depth = function_depth

    print()

    print(markdown_table(TABLE_TITLES, results))


def install_missing_modules():
    try:
        import psutil
    except ImportError:
        print("Installing missing modules...")
        pip.main(["install", "psutil"])
        print("Missing modules installed successfully.")


if __name__ == '__main__':
    main()
