#!/usr/bin/env python3

# TODO use class Row

import sys
import argparse
import subprocess as sp
import os
import stat
import os.path
from shutil import which
import time
from pprint import pprint
import random
from datetime import datetime
from os.path import expanduser
from itertools import product as iter_product

from string import Template as Tm
from timeit import default_timer as timer

from process_timer import ProcessTimer


SUPPORTED_LANGUAGES = ['C', 'C++', 'Ada', 'C#', 'Swift', 'Java', 'D', 'Vox', 'Rust', 'Nim', 'Zig', 'Go', 'V', 'C3', 'Julia', 'OCaml']
TEMPLATED_SUPPORTED_LANGUAGES = ['C++', 'Java', 'D', 'Swift', 'Vox', 'Rust', 'Zig', 'V', 'C3', 'Julia']
SUPPORTED_OPERATIONS = ['Check', 'Compile', 'Build']
DEFAULT_PROGRAM_NAME = 'main'

C_WARN_FLAGS = ['-Wall', '-Wextra', '-Wno-c++11-extensions']

RUSTC_NO_WARNINGS_FLAGS = ['-A', 'warnings']  # flags that disable warnings for `rustc`
RUSTC_FLAGS = []          # set to `RUSTC_NO_WARNINGS_FLAGS` to disable warnings

JULIA_EXE_FLAGS = ['--compile=min']

ROOT_PATH = 'generated'
RANGE = range(5, 15)
VERSIONS = [""] + [f"-{i}" for i in RANGE]

HOME = os.path.expanduser("~")  # instead of home = os.getenv('HOME') that doesnâ€™t work on Windows


class Row:                      # TODO use
    __slots__ = ['lang',
                 'templated',
                 'check_dur_per_func',
                 'build_dur_per_func',
                 'run_dur_per_func',
                 'rss_mu',
                 'exe_version',
                 'exe_path']
    def __init__(self,
                 lang,
                 templated,
                 check_dur_per_func,
                 build_dur_per_func,
                 run_dur_per_func,
                 rss_mu,
                 exe_version,
                 exe_path):
        self.lang = lang
        self.templated=templated
        self.check_dur_per_func=check_dur_per_func
        self.build_dur_per_func=build_dur_per_func
        self.run_dur_per_func=run_dur_per_func
        self.rss_mu=rss_mu
        self.exe_version=exe_version
        self.exe_pat=exe_path


class Row(object):
    """Result row."""
    def __init__(self, args):
        self.args = args


TABLE_TITLES = ['Lang-uage', 'Temp-lated', 'Check Time [us/fn]', 'Compile Time [us/fn]', 'Build Time [us/fn]', 'Run Time [us/fn]', 'Check RSS [kB/fn]', 'Build RSS [kB/fn]', 'Exec Version', 'Exec Path']
LANG_IX = 0
TEMPLATED_IX = 1
CHECK_DUR_PER_FUNC_IX = 2       # check duration
COMPILE_DUR_PER_FUNC_IX = 3       # compilation duration
BUILD_DUR_PER_FUNC_IX = 4       # build duration
RUN_DUR_PER_FUNC_IX = 5       # run duration
CHECK_RSS_MU_IX = 6        # check RSS memory usage
BUILD_RSS_MU_IX = 7        # build RSS memory usage
EXE_VERSION_IX = 8
EXE_PATH_IX = 9
TABLE_LENGTH = EXE_PATH_IX + 1

assert len(TABLE_TITLES) == TABLE_LENGTH

def table_row(row,
              args,
              lang,
              op,
              exe_path,
              compiler_version,
              check_dur,
              compile_dur,
              build_dur,
              run_dur,
              check_rss_mu,
              build_rss_mu,
              templated):

    if exe_path.startswith(HOME):
        exe_path = os.path.join('~', exe_path.lstrip(HOME))

    row[LANG_IX] = lang
    row[TEMPLATED_IX] = 'Yes' if templated else 'No'

    if check_dur is not None:
        row[CHECK_DUR_PER_FUNC_IX] = check_dur / (args.function_count * args.function_depth)

    if compile_dur is not None:
        row[COMPILE_DUR_PER_FUNC_IX] = compile_dur / (args.function_count * args.function_depth)

    if build_dur is not None:
        row[BUILD_DUR_PER_FUNC_IX] = build_dur / (args.function_count * args.function_depth)

    if run_dur is not None:
        row[RUN_DUR_PER_FUNC_IX] = run_dur / (args.function_count * args.function_depth)

    if isinstance(check_rss_mu, (int, float)):
        row[CHECK_RSS_MU_IX] = check_rss_mu / (args.function_count * args.function_depth)
    elif check_rss_mu is not None:
        row[CHECK_RSS_MU_IX] = check_rss_mu

    if isinstance(build_rss_mu, (int, float)):
        row[BUILD_RSS_MU_IX] = build_rss_mu / (args.function_count * args.function_depth)
    elif build_rss_mu is not None:
        row[BUILD_RSS_MU_IX] = build_rss_mu

    row[EXE_VERSION_IX] = compiler_version
    row[EXE_PATH_IX] = exe_path

    return row

RANDOMIZE_FLAG = True

if RANDOMIZE_FLAG:
    random.seed(str(datetime.now()))


def get_version(version_run):
    result = next(part
                  for part
                  in version_run.stdout.decode('utf-8').split()
                  if (part[0].isdigit() or
                      part[0] == 'v' and part[1].isdigit())) # v2.096.1-beta.1-187-gb25be89b3
    return result.split('~')[0].split('ubuntu1')[0]  # strip ubuntu version postfix


def touchFile(path):
    with open(path, 'a'):
        os.utime(path, None)


def out_directory(lang):
    return os.path.join(ROOT_PATH,
                        lang.lower())


def out_binary(lang):
    return DEFAULT_PROGRAM_NAME


def sourceIdOf(lang, templated, run_ix):
    if lang in TEMPLATED_SUPPORTED_LANGUAGES:
        key = lang + ('-Templated' if templated else '-Untemplated')
    else:
        key = lang
    return key + "-" + str(run_ix)


def fill_in_speedups(results, column_ix):
    # calculate minimum
    min_key = None               # key of minimum
    min_val = None               # value of minimum
    for key, result in results.items():
        if isinstance(result[column_ix], (int, float)):
            if min_val is None or (min_val > result[column_ix]):
                min_key = key
                min_val = result[column_ix]
    if min_key is not None:
        rel_tag = results[min_key][EXE_PATH_IX]
        for key, result in results.items():
            result[column_ix] = stringify_metrics(abs_n=result[column_ix],
                                                  min_val=min_val,
                                                  column_ix=column_ix,
                                                  rel_tag=rel_tag)


def stringify_metrics(abs_n, min_val, column_ix, rel_tag):
    if isinstance(abs_n, str):
        return '{:>13}'.format(abs_n)            # propagate as is
    if abs_n is None:
        return '{:>6}'.format('N/A')  # https://en.wikipedia.org/wiki/N/A
    if abs_n == min_val:
        rel_str = " (best)"
    else:
        rel_n = abs_n / min_val
        rel_str = " (" + factor_str(rel_n) + "x" ")"
    if column_ix == CHECK_DUR_PER_FUNC_IX:
        return to_str_in_microseconds(abs_n) + rel_str
    elif column_ix == COMPILE_DUR_PER_FUNC_IX:
        return to_str_in_microseconds(abs_n) + rel_str
    elif column_ix == BUILD_DUR_PER_FUNC_IX:
        return to_str_in_microseconds(abs_n) + rel_str
    elif column_ix == RUN_DUR_PER_FUNC_IX:
        return to_str_in_nanoseconds(abs_n) + rel_str
    elif column_ix == CHECK_RSS_MU_IX:
        return to_str_memory_usage(abs_n) + rel_str
    elif column_ix == BUILD_RSS_MU_IX:
        return to_str_memory_usage(abs_n) + rel_str


def to_str_in_microseconds(dur):
    return '{:6.1f}'.format(1e6 * dur)


def to_str_in_nanoseconds(dur):
    return '{:6.0f}'.format(1e9 * dur) if dur is not None else ''


def factor_str(factor):
    return '{:.1f}'.format(factor)


def to_str_memory_usage(mu):
    return '{:6.1f}'.format(mu / 1e3)


def repeat_to_length(string_to_expand, length):
    return (string_to_expand * (int(length / len(string_to_expand)) + 1))[:length]


def markdown_header(text, nr):        # Markdown header
    return '#' * nr + ' ' + text


def markdown_table(titles, results):
    fill_in_speedups(results=results, column_ix=CHECK_DUR_PER_FUNC_IX)
    fill_in_speedups(results=results, column_ix=COMPILE_DUR_PER_FUNC_IX)
    fill_in_speedups(results=results, column_ix=BUILD_DUR_PER_FUNC_IX)
    fill_in_speedups(results=results, column_ix=RUN_DUR_PER_FUNC_IX)
    fill_in_speedups(results=results, column_ix=CHECK_RSS_MU_IX)
    fill_in_speedups(results=results, column_ix=BUILD_RSS_MU_IX)

    result = ''

    for col in titles:
        result += '| ' + str(col) + ' '
    result += '\n'

    for ix, col in enumerate(range(len(titles))):
        if ix == TEMPLATED_IX:
            result += '| ' + repeat_to_length("-", len(titles[ix])) + ' '
        else:
            result += '| ' + ':' + repeat_to_length("-", len(titles[ix]) - 2) + ':' + ' '
    result += '\n'

    for key, row in results.items():
        for ix, cl in enumerate(range(len(titles))):
            col = row[ix]
            col_str = str(col) if col is not None else 'N/A'
            result += '| ' + col_str + repeat_to_length(" ", len(titles[ix]) - len(col_str)) + ' '
        result += '\n'
    return result


def main():
    parser = argparse.ArgumentParser(formatter_class=argparse.ArgumentDefaultsHelpFormatter)

    parser.add_argument('--languages', '--langs', type=str,
                        default=','.join(SUPPORTED_LANGUAGES),
                        help='Languages (optionally combined with compilers) to benchmark separated by comma. For instance --languages=C:tcc,D:dmd.')

    parser.add_argument('--operations', '--ops', type=str,
                        default=','.join(SUPPORTED_OPERATIONS),
                        help='Operations to perform separated by comma')

    parser.add_argument('--function-count', '--fc', type=int,
                        default=100,
                        help='Number of functions generated and called')

    parser.add_argument('--function-depth', '--fd', type=int,
                        default=100,
                        help='Function call depth')

    parser.add_argument('--sample-rate', '--sr', type=int,
                        default=100,
                        help='Rate of memory usage sampling. Unit is samples per second.')

    parser.add_argument('--run-count', '--rc', type=int,
                        default=1,
                        help='Number of runs for each compilation')

    parser.add_argument('--path', dest='path', nargs='+',
                        default=["/usr/local/bin"],
                        help='Search paths for binaries (eg: --path=/usr/bin:/usr/local/bin)')

    args = parser.parse_args()

    args.languages = list(map(lambda x: 'OCaml' if x.lower() == 'ocaml' else x.capitalize(),
                              args.languages.split(',')))  # into a list
    filtered_languages = []
    args.language_exe = {}
    for language in args.languages:
        split = language.split(':')
        if len(split) == 2:
            language = split[0]
            exes = split[1]
            args.language_exe[language] = tuple(exes.split())
        if language in SUPPORTED_LANGUAGES:
            filtered_languages.append(language)
        else:
            print('Warning: Ignoring unsupported language ' + language)
    args.languages = filtered_languages

    args.operations = list(map(lambda x: x.capitalize(), args.operations.split(',')))  # into a list of capitalized names
    filtered_operations = []
    for operation in args.operations:
        if operation in SUPPORTED_OPERATIONS:
            filtered_operations.append(operation)
        else:
            print('Warning: Ignoring unsupported operation ' + operation)
    args.operations = filtered_operations

    code_paths = {}
    results = {}            # tuple(LANGUAGE, TEMPLATEFLAG) => list

    print(markdown_header('Benchmark:', 1))

    for op in args.operations:
        if 'Vox' in args.languages:
            for templated in (False, True):
                benchmark_Vox(results=results, code_paths=code_paths, args=args, op=op, templated=templated)
                benchmark_Vox(results=results, code_paths=code_paths, args=args, op=op, templated=templated)
        if 'D' in args.languages:
            for templated in (False, True):
                benchmark_D(results=results, code_paths=code_paths, args=args, op=op, templated=templated, use_dips=True)
        if 'C' in args.languages:
            for templated in (False,):
                benchmark_C_using_tcc(results=results, lang='C', code_paths=code_paths, args=args, op=op, templated=templated)
                benchmark_C_using_cproc(results=results, lang='C', code_paths=code_paths, args=args, op=op, templated=templated)
                benchmark_C_and_Cxx_using_gcc(results=results, lang='C', code_paths=code_paths, args=args, op=op, templated=templated)
                benchmark_C_and_Cxx_using_clang(results=results, lang='C', code_paths=code_paths, args=args, op=op, templated=templated)
        if 'C++' in args.languages:
            for templated in (False, True):
                benchmark_C_and_Cxx_using_gcc(results=results, lang='C++', code_paths=code_paths, args=args, op=op, templated=templated)
                benchmark_C_and_Cxx_using_clang(results=results, lang='C++', code_paths=code_paths, args=args, op=op, templated=templated)

    if 'Ada' in args.languages:
        # if 'Check' in args.operations:
        #     benchmark_Ada_using_gcc(results=results,lang='Ada', code_paths=code_paths, args=args, op='Check', templated=False)
        if 'Build' in args.operations:
            benchmark_Ada_using_gcc(results=results, lang='Ada', code_paths=code_paths, args=args, op='Build', templated=False)

    if 'Go' in args.languages:
        if 'Check' in args.operations:
            benchmark_Go(results=results, code_paths=code_paths, args=args, op='Check', templated=False)
        if 'Build' in args.operations:
            benchmark_Go(results=results, code_paths=code_paths, args=args, op='Build', templated=False)

    if 'Swift' in args.languages:
        if 'Check' in args.operations:
            benchmark_Swift(results=results, code_paths=code_paths, args=args, op='Check', templated=False)
        if 'Build' in args.operations:
            benchmark_Swift(results=results, code_paths=code_paths, args=args, op='Build', templated=False)

    if 'V' in args.languages:
        if 'Build' in args.operations:
            benchmark_V(results=results, code_paths=code_paths, args=args, op='Build', templated=False)
            benchmark_V(results=results, code_paths=code_paths, args=args, op='Build', templated=True)

    if 'C3' in args.languages:
        if 'Build' in args.operations:
            benchmark_C3(results=results, code_paths=code_paths, args=args, op='Build', templated=False)

    if 'Zig' in args.languages:
        if 'Check' in args.operations:
            benchmark_Zig(results=results, code_paths=code_paths, args=args, op='Check', templated=False)
            benchmark_Zig(results=results, code_paths=code_paths, args=args, op='Check', templated=True)
        if 'Build' in args.operations:
            benchmark_Zig(results=results, code_paths=code_paths, args=args, op='Build', templated=False)
            benchmark_Zig(results=results, code_paths=code_paths, args=args, op='Build', templated=True)

    if 'Rust' in args.languages:
        if 'Check' in args.operations:
            benchmark_Rust(results=results, code_paths=code_paths, args=args, op='Check', templated=False)
            benchmark_Rust(results=results, code_paths=code_paths, args=args, op='Check', templated=True)
        if 'Build' in args.operations:
            benchmark_Rust(results=results, code_paths=code_paths, args=args, op='Build', templated=False)
            benchmark_Rust(results=results, code_paths=code_paths, args=args, op='Build', templated=True)

    if 'Nim' in args.languages:
        if 'Check' in args.operations:
            benchmark_Nim(results=results, code_paths=code_paths, args=args, op='Check', templated=False)
        if 'Build' in args.operations:
            benchmark_Nim(results=results, code_paths=code_paths, args=args, op='Build', templated=False)

    if 'C#' in args.languages:
        if 'Build' in args.operations:
            benchmark_Mono(results=results, code_paths=code_paths, args=args, op='Build', templated=False)

    if 'Java' in args.languages:
        if 'Build' in args.operations:
            benchmark_Java(results=results, code_paths=code_paths, args=args, op='Build', templated=False)

    # Julia and Ocaml take too long otherwise. So let them participate by
    # truncating size because ops/function are measured
    function_count = args.function_count
    function_depth = args.function_depth
    if args.function_count * args.function_depth >= 10000:
        args.function_count = 100
        args.function_depth = 100

    if 'OCaml' in args.languages:
        if 'Build' in args.operations:
            benchmark_OCaml(results=results, code_paths=code_paths, args=args, op='Build', templated=False, bytecode=False)
            benchmark_OCaml(results=results, code_paths=code_paths, args=args, op='Build', templated=False, bytecode=True)

    if 'Julia' in args.languages:
        if 'Build' in args.operations:
            benchmark_Julia(results=results, code_paths=code_paths, args=args, op='Build', templated=False)
            benchmark_Julia(results=results, code_paths=code_paths, args=args, op='Build', templated=True)

    args.function_count = function_count
    args.function_depth = function_depth

    print()

    print(markdown_table(TABLE_TITLES, results))


def match_lang(args, lang, exe_name, path=None):
    try:
        if exe_name not in args.language_exe[lang]:
            return None
    except KeyError:
        pass
    return which(exe_name, path=path)


def benchmark_Ada_using_gcc(results, lang, code_paths, args, op, templated):
    exe_flags = ['compile'] if op == 'Build' else ['check']
    tested_bins = []
    for path, gcc_version in iter_product(args.path, VERSIONS):
        exe = match_lang(args, lang, 'gnat' + str(gcc_version), path=path)
        if exe and exe not in tested_bins:
            tested_bins.append(exe)
            version = get_version(sp.run([exe, '--version'], stdout=sp.PIPE))
            compile_file(code_paths,
                         out_flag_and_exe=['-o', out_binary(lang)],
                         exe=exe,
                         runner=True,
                         exe_flags=exe_flags,
                         args=args,
                         op=op,
                         compiler_version=version,
                         lang=lang,
                         templated=templated,
                         results=results)


def benchmark_C_using_cproc(results, lang, code_paths, args, op, templated):
    if op == 'Check':
        exe_flags = ['-emit-qbe']
        out_flag_and_exe = ['-o', '/dev/null']
    elif op == 'Compile':
        exe_flags = ['-c']
        out_flag_and_exe = ['-o', '/dev/null']
    elif op == 'Build':
        exe_flags = []
        out_flag_and_exe = ['-o', out_binary(lang)]
        # Disable build for now until I find out how to fix linker errors:
        # ld: error: unable to find library -l:crt1.o
        # ld: error: unable to find library -l:crti.o
        # ld: error: unable to find library -lc
        # ld: error: unable to find library -l:crtn.o
        # cproc: link: process 2424876 exited with status 1
        return False
    else:
        return None
    for path in args.path:
        exe = match_lang(args, lang, 'cproc', path=path)
        if exe:
            version = 'unknown'
            compile_file(code_paths,
                        out_flag_and_exe=out_flag_and_exe,
                        exe=exe,
                        runner=(op == 'Build'),
                        exe_flags=exe_flags,
                        args=args,
                        op=op,
                        compiler_version=version,
                        lang=lang,
                        templated=templated,
                        results=results)


def benchmark_C_using_tcc(results, lang, code_paths, args, op, templated):
    if op == 'Check':
        exe_flags = ['-c']
        out_flag_and_exe = ['-o', '/dev/null']
    elif op == 'Compile':
        exe_flags = ['-c']
        out_flag_and_exe = []
    elif op == 'Build':
        exe_flags = [] # TODO add version that skips linking via: exe_flags = ['-c']
        out_flag_and_exe = ['-o', out_binary(lang)]
    else:
        return None
    for path in args.path:
        exe = match_lang(args, lang, 'tcc', path=path)
        if exe:
            version = get_version(sp.run([exe, '-v'], stdout=sp.PIPE))
            compile_file(code_paths,
                        out_flag_and_exe=out_flag_and_exe,
                        exe=exe,
                        runner=(op == 'Build'),
                        exe_flags=exe_flags,
                        args=args,
                        op=op,
                        compiler_version=version,
                        lang=lang,
                        templated=templated,
                        results=results)


def gcc_clang_op_flags(op, lang):
    if op == 'Check':
        exe_flags = ['-c', '-fsyntax-only']
        out_flag_and_exe = []
    elif op == 'Compile':
        exe_flags = ['-c']
        out_flag_and_exe = []
    elif op == 'Build':
        exe_flags = [] # TODO add version that skips linking via: exe_flags = ['-c']
        out_flag_and_exe = ['-o', out_binary(lang)]
    else:
        return (None, None)
    return (exe_flags, out_flag_and_exe)


def benchmark_C_and_Cxx_using_gcc(results, lang, code_paths, args, op, templated):
    (exe_flags, out_flag_and_exe) = gcc_clang_op_flags(op, lang)
    if exe_flags is None:
        return none
    tested_bins = []
    for path, gcc_version in iter_product(args.path,VERSIONS):
        if lang == 'C':
            exe = match_lang(args, lang, 'gcc' + str(gcc_version), path=path)
        elif lang == 'C++':
            exe = match_lang(args, lang, 'g++' + str(gcc_version), path=path)
        else:
            return None
        if exe and exe not in tested_bins:
            tested_bins.append(exe)
            version = sp.run([exe, '--version'], stdout=sp.PIPE).stdout.decode('utf-8').split()[2].split('-')[0]
            compile_file(code_paths,
                         out_flag_and_exe=out_flag_and_exe,
                         exe=exe,
                         runner=True,
                         exe_flags=exe_flags + C_WARN_FLAGS,
                         args=args,
                         op=op,
                         compiler_version=version,
                         lang=lang,
                         templated=templated,
                         results=results)


def benchmark_C_and_Cxx_using_clang(results, lang, code_paths, args, op, templated):
    (exe_flags, out_flag_and_exe) = gcc_clang_op_flags(op, lang)
    if exe_flags is None:
        return none
    C_CLANG_FLAGS = C_WARN_FLAGS + ['-fno-color-diagnostics', '-fno-caret-diagnostics', '-fno-diagnostics-show-option']
    tested_bins = []
    for path, clang_version in iter_product(args.path, VERSIONS):
        if lang == 'C':
            exe = match_lang(args, lang, 'clang' + str(clang_version), path=path)
        elif lang == 'C++':
            exe = match_lang(args, lang, 'clang' + str(clang_version), path=path)
        else:
            return None
        if exe and exe not in tested_bins:
            tested_bins.append(exe)
            version = get_version(sp.run([exe, '--version'], stdout=sp.PIPE))
            compile_file(code_paths,
                         out_flag_and_exe=out_flag_and_exe,
                         exe=exe,
                         runner=True,
                         exe_flags=C_CLANG_FLAGS + exe_flags,
                         args=args,
                         op=op,
                         compiler_version=version,
                         lang=lang,
                         templated=templated,
                         results=results)


def benchmark_D(results, code_paths, args, op, templated, use_dips):
    lang = 'D'
    d_flags = ['-w', '-dip25', '-dip1008', '-dip1000'] if use_dips else []

    if op == 'Check':
        exe_flags = ['-o-']
    elif op == 'Compile':
        exe_flags = ['-c']
    elif op == 'Build':
        if which('ld.lld') is not None:
            exe_flags = ["-Xcc=-fuse-ld=lld"]
        elif which('ld.gold') is not None:
            exe_flags = ["-Xcc=-fuse-ld=gold"]
        else:
            exe_flags = []
    else:
        return None

    # DMD
    for path in args.path:
        exe = match_lang(args, lang, 'dmd', path=path)
        if exe:
            version = get_version(sp.run([exe, '--version'], stdout=sp.PIPE))
            compile_file(code_paths=code_paths,
                        out_flag_and_exe=['-of=' + out_binary(lang)] if op == 'Build' else [],
                        exe=exe,
                        runner=True,
                        exe_flags=d_flags + exe_flags,
                        args=args,
                        op=op,
                        compiler_version=version,
                        lang=lang,
                        templated=templated,
                        results=results)

        # LDC
        exe = match_lang(args, lang, 'ldmd2', path=path)
        if exe:
            version = sp.run([exe, '--version'], stdout=sp.PIPE).stdout.decode('utf-8').split()[6][1:-2]
            compile_file(code_paths=code_paths,
                        out_flag_and_exe=['-of=' + out_binary(lang)] if op == 'Build' else [],
                        exe=exe,
                        runner=True,
                        exe_flags=d_flags + exe_flags,
                        args=args,
                        op=op,
                        compiler_version=version,
                        lang=lang,
                        templated=templated,
                        results=results)

        # GDC
        exe = match_lang(args, lang, 'gdc', path=path)
        if exe:
            exe_flags = ['-fsyntax-only'] if op == 'Check' else []
            version = sp.run([exe, '--version'], stdout=sp.PIPE).stdout.decode('utf-8').split()[3]
            compile_file(code_paths=code_paths,
                        out_flag_and_exe=['-o' + out_binary(lang)] if op == 'Build' else [],
                        exe=exe,
                        runner=True,
                        exe_flags=exe_flags,
                        args=args,
                        op=op,
                        compiler_version=version,
                        lang=lang,
                        templated=templated,
                        results=results)


def benchmark_Vox(results, code_paths, args, op, templated):
    lang = 'Vox'
    if op == 'Check':
        exe_flags = ['--check-only']
        out_flag_and_exe = []
    elif op == 'Compile':
        return None             # no supported
    elif op == 'Build':
        exe_flags = []
        out_flag_and_exe = ['--of=' + out_binary(lang)]
    else:
        return None
    for path in args.path:
        exe = match_lang(args, lang, 'vox', path=path)
        if exe:
            compile_file(code_paths,
                        out_flag_and_exe=out_flag_and_exe,
                        exe=exe,
                        runner=True,  # os.name == 'nt', # only on Windows for now. TODO https://forum.dlang.org/post/cjbaiikzfbqkjqoukljc@forum.dlang.org
                        exe_flags=exe_flags,
                        args=args,
                        op=op,
                        compiler_version='master',  # TODO lookup Git version
                        lang=lang,
                        templated=templated,
                        results=results)


def benchmark_Mono(results, code_paths, args, op, templated):
    lang = 'C#'
    for path in args.path:
        exe = match_lang(args, lang, 'mcs', path=path)
        if exe:
            exe_flags = ['-target:exe'] + ([] if op == 'Build' else [''])
            version = sp.run([exe, '--version'], stdout=sp.PIPE).stdout.decode('utf-8').split()[4]
            compile_file(code_paths,
                        out_flag_and_exe=['-out:' + out_binary(lang)],
                        exe=exe,
                        runner=True,
                        exe_flags=exe_flags,
                        args=args,
                        op=op,
                        compiler_version=version,
                        lang=lang,
                        templated=templated,
                        results=results)


def benchmark_Go(results, code_paths, args, op, templated):
    benchmark_Go_using_go(results, code_paths, args, op, templated)
    benchmark_Go_using_gccgo(results, code_paths, args, op, templated)


def benchmark_Go_using_go(results, code_paths, args, op, templated):
    lang = 'Go'
    version = None              # unknown
    for path in args.path:
        if op == 'Build':
            exe = which('go', path=path)
            exe_flags = ['build']
            version = sp.run([exe, 'version'], stdout=sp.PIPE).stdout.decode('utf-8').split()[2][2:]
            out_flag_and_exe = ['-o', out_binary(lang)]
        elif op == 'Check':
            exe = which('gotype', path=path)
            exe_flags = []
            version_exe = which('go')  # guess it be same as `go`
            if version_exe is not None:
                version = sp.run([version_exe, 'version'], stdout=sp.PIPE).stdout.decode('utf-8').split()[2][2:]
            out_flag_and_exe = []
        else:
            return None
        exe = match_lang(args, lang, exe, path=path)
        if exe:
            compile_file(code_paths,
                        out_flag_and_exe=out_flag_and_exe,
                        exe=exe,
                        runner=True,
                        exe_flags=exe_flags,
                        args=args,
                        op=op,
                        compiler_version=version,
                        lang=lang,
                        templated=templated,
                        results=results)


def benchmark_Go_using_gccgo(results, code_paths, args, op, templated):
    lang = 'Go'
    tested_bins = []
    for path, gccgo_version in iter_product(args.path, VERSIONS):
        exe = match_lang(args, lang, 'gccgo' + str(gccgo_version), path=path)
        if exe and exe not in tested_bins:
            tested_bins.append(exe)
            version = sp.run([exe, '--version'], stdout=sp.PIPE).stdout.decode('utf-8').split()[3]
            compile_file(code_paths,
                         out_flag_and_exe=[],  # TODO this fails out_flag_and_exe=['-o', out_binary(lang)],
                         exe=exe,
                         runner=True,
                         exe_flags=[] if op == 'Build' else ['-fsyntax-only', '-S'],
                         args=args,
                         op=op,
                         compiler_version=version,
                         lang=lang,
                         templated=templated,
                         results=results)


def benchmark_Swift(results, code_paths, args, op, templated):
    lang = 'Swift'
    for path in PATH:
        exe = (match_lang(args, lang, 'swiftc', path=path if args.env_path else None) or
            which(os.path.join(HOME, '.local/swift-5.3.3-RELEASE-ubuntu20.04/usr/bin/swiftc')))
        if op == 'Build':
            exe_flags = ['']
        elif op == 'Check':
            exe_flags = ['-typecheck']
        else:
            return None
        if exe:
            version = sp.run([exe, '--version'], stdout=sp.PIPE).stdout.decode('utf-8').split()[2]
            compile_file(code_paths,
                        out_flag_and_exe=['-o', out_binary(lang)],
                        exe=exe,
                        runner=True,
                        exe_flags=exe_flags,
                        args=args,
                        op=op,
                        compiler_version=version,
                        lang=lang,
                        templated=templated,
                        results=results)


def benchmark_OCaml(results, code_paths, args, op, templated, bytecode):
    lang = 'OCaml'
    for path in PATH:
        if bytecode:
            exe = match_lang(args, lang, 'ocamlc', path=path if args.env_path else None)
        else:
            exe = match_lang(args, lang, 'ocamlopt', path=path if args.env_path else None)
        if exe:
            version = sp.run([exe, '--version'], stdout=sp.PIPE).stdout.decode('utf-8').split()[0]
            compile_file(code_paths,
                        out_flag_and_exe=['-o', out_binary(lang)],
                        exe=exe,
                        runner=([which('ocamlrun')] if
                                bytecode else
                                True),
                        exe_flags=['-c'] if bytecode else [],
                        args=args,
                        op=op,
                        compiler_version=version,
                        lang=lang,
                        templated=templated,
                        results=results)


def benchmark_V(results, code_paths, args, op, templated):
    lang = 'V'                                   # vlang.io
    for path in PATH:
        exe = match_lang(args, lang, 'v', path=path if args.env_path else None)
        if exe:
            version = sp.run([exe, '--version'], stdout=sp.PIPE).stdout.decode('utf-8').split()[1]
            vlang_backends = ['native', 'c', 'js', 'x64', 'v2', 'experimental']
            compile_file(code_paths,
                        out_flag_and_exe=['-o', out_binary(lang)],
                        exe=exe,
                        runner=True,
                        exe_flags=['-backend', vlang_backends[1]],
                        args=args,
                        op=op,
                        compiler_version=version,
                        lang=lang,
                        templated=templated,
                        results=results)


def benchmark_C3(results, code_paths, args, op, templated):
    lang = 'C3'
    for path in PATH:
        exe = (match_lang(args, lang, 'c3c', path=path if args.env_path else None) or
            which(os.path.join(HOME, 'ware/c3c/build/c3c')))
        if exe:
            version = 'unknown'
            compile_file(code_paths,
                        out_flag_and_exe=['-o', out_binary(lang)],
                        exe=exe,
                        runner=True,
                        exe_flags=['compile'],
                        args=args,
                        op=op,
                        compiler_version=version,
                        lang=lang,
                        templated=templated,
                        results=results)


def benchmark_Zig(results, code_paths, args, op, templated):
    lang = 'Zig'
    for path in PATH:
        exe = match_lang(args, lang, 'zig', path=path if args.env_path else None)
        if exe:
            version = sp.run([exe, 'version'], stdout=sp.PIPE).stdout.decode('utf-8').split()[0]
            compile_file(code_paths,
                        out_flag_and_exe=['--name', out_binary(lang)],
                        exe=exe,
                        runner=True,
                        exe_flags=['build-exe'] if op == 'Build' else ['build-obj', '-fno-emit-bin'],
                        args=args,  # no syntax flag currently so compile to object file instead
                        op=op,
                        compiler_version=version,
                        lang=lang,
                        templated=templated,
                        results=results)

def benchmark_Nim(results, code_paths, args, op, templated, exe_flags=None):
    lang = 'Nim'
    for path in PATH:
        exe = match_lang(args, lang, 'nim', path=path if args.env_path else None)

        tcc_exe = which('tcc', path=path if args.env_path else None)
        exe_flags = ['--hints:off', '--checks:off', '--stacktrace:off'] + ([('--cc:tcc')] if tcc_exe else [])

        if op == 'Check':
            exe_flags += ['check']
        elif op == 'Build':
            # the bottleneck is clang compilation
            exe_flags += ['c', '--gc:refc', '--opt:none']  # TODO detect when --gc:arc is available
        else:
            return None
        if exe:
            version = sp.run([exe, '--version'], stdout=sp.PIPE).stdout.decode('utf-8').split()[3]
            compile_file(code_paths,
                        out_flag_and_exe=['--out:' + out_binary(lang)],
                        exe=exe,
                        runner=True,
                        exe_flags=exe_flags,
                        args=args,  # no syntax flag currently so compile to object file instead
                        op=op,
                        compiler_version=version,
                        lang=lang,
                        templated=templated,
                        results=results)


def set_rustup_channel(channel):
    with sp.Popen(['rustup', 'default', channel],
                  stdout=sp.PIPE,
                  stderr=sp.PIPE) as proc:
        proc.communicate()


def benchmark_Rust(results, code_paths, args, op, templated):
    lang = 'Rust'
    for path in PATH:
        rustup_exe = which('rustup', path=path if args.env_path else None)
        if rustup_exe:
            rustup_channels = ['stable', 'nightly']
        else:
            rustup_channels = [None]

        for channel in rustup_channels:
            if rustup_exe is not None:
                set_rustup_channel(channel)

            exe = match_lang(args, lang, 'rustc', path=path if args.env_path else None)
            if exe:
                # See: https://stackoverflow.com/questions/53250631/does-rust-have-a-way-to-perform-syntax-and-semantic-analysis-without-generating/53250674#53250674
                # See: https://stackoverflow.com/questions/51485765/run-rustc-to-check-a-program-without-generating-any-files
                # Alternatives:
                # - `rustc --emit=metadata -Z no-codegen`
                # - Not yet in stable: `rustc -Z no-codegen`
                # - 'rustc', '--crate-type', 'lib', '--emit=mir', '-o', '/dev/null', '--test'
                version = sp.run([exe, '--version'], stdout=sp.PIPE).stdout.decode('utf-8').split()[1]
                if op == 'Check':
                    if channel == 'nightly':
                        check_args = ['-Z', 'no-codegen']  # TODO why is this not available on stable yet?
                    else:
                        check_args = ['--emit=mir', '-o', '/dev/null']  # Used by Flycheck. Twice as slow as `-Z no-codegen`
                    out_flag_and_exe = []
                elif op == 'Build':
                    out_flag_and_exe = ['-o', out_binary(lang)]
                else:
                    continue
                exe_flags = ([] if op == 'Build' else check_args) + RUSTC_FLAGS
                compile_file(code_paths,
                            out_flag_and_exe=out_flag_and_exe,
                            exe=exe,
                            runner=True,
                            exe_flags=exe_flags,  # https://github.com/rust-lang/rfcs/issues/1476
                            args=args,
                            op=op,
                            compiler_version=version,
                            lang=lang,
                            templated=templated,
                            results=results)

def benchmark_Java(results, code_paths, args, op, templated):
    lang = 'Java'
    for path in PATH:
        exe = match_lang(args, lang, 'javac', path=path if args.env_path else None)
        if exe:
            try:
                task = sp.run([exe, '-version'],
                            stdout=sp.PIPE,
                            stderr=sp.PIPE)
                version = (task.stdout or task.stderr).decode('utf-8').split()[1]
            except:
                print("WARNING: Failed to decode version from neither stdout:" + str(task.stdout) + " nor stderr:" + str(task.stderr) +
                    " of command " + str([exe, '-version']) + ", defaulting version of " + lang + " to `none`",
                    file=sys.stderr)
                version = 'unknown'
            compile_file(code_paths,
                        out_flag_and_exe=[],
                        exe=exe,
                        runner=[which('java'), '-classpath', '.'],
                        exe_flags=['-Xdiags:verbose'],
                        args=args,
                        op=op,
                        compiler_version=version,
                        lang=lang,
                        templated=templated,
                        results=results)


def benchmark_Julia(results, code_paths, args, op, templated):
    lang = 'Julia'
    for path in PATH:
        exe = match_lang(args, lang, 'julia', path=path if args.env_path else None)
        if exe:
            version = sp.run([exe, '--version'], stdout=sp.PIPE).stdout.decode('utf-8').split()[2]
            compile_file(code_paths,
                        out_flag_and_exe=[],
                        exe=exe,
                        runner=False,
                        exe_flags=JULIA_EXE_FLAGS,
                        args=args,
                        op=op,
                        compiler_version=version,
                        lang=lang,
                        templated=templated,
                        results=results)


def compile_file(code_paths,
                 out_flag_and_exe,
                 exe,
                 runner,
                 exe_flags,
                 args,
                 op='Check',
                 compiler_version=None,
                 lang=None,
                 templated=None,
                 results=None):
    key = (lang, templated, exe)

    if key not in results:
        row = [None] * TABLE_LENGTH  # preallocate
        results[key] = row
    else:
        row = results[key]

    # op
    durs = []                  # compilation durations
    rss_mu = None                    # RSS memory usage
    for run_ix in range(0, args.run_count):
        src_key = sourceIdOf(lang, templated, run_ix)

        if src_key in code_paths:
            src_path = code_paths[src_key]  # retrieve from cache
        else:
            src_path = generate_test_program_file(lang, args, templated, run_ix)  # generate
            code_paths[src_key] = src_path  # store in cache
        src_name = os.path.basename(src_path)

        cstart = timer()        # compilation start
        p_args = [exe] + exe_flags + out_flag_and_exe + [src_name]
        # print("p_args:", ' '.join(p_args))
        cwd = os.getcwd()
        os.chdir(out_directory(lang))
        pt = ProcessTimer(args=p_args)
        try:
            while pt.poll():
                time.sleep(1.0 / args.sample_rate)  # poll as often as possible
        except:
            # if rss_mu is None and pt.max_rss_mu != 0:
            #     rss_mu = pt.max_rss_mu
            # if rss_mu is None:
            #     rss_mu = "unavailable"
            rss_mu = "sampling error"  # precision of maximum is uncertain
        finally:
            if rss_mu is None and pt.max_rss_mu != 0:
                rss_mu = pt.max_rss_mu
            if rss_mu is None:
                rss_mu = "sampling miss"
        # TODO pt.assertClosed() needed?
        outs, errs = pt.comp_proc.communicate()
        os.chdir(cwd)           # restore

        # print('Compilation:', ' '.join([exe] + exe_flags + out_flag_and_exe + src_name))
        if pt.comp_proc.returncode != 0:
            print("WARNING: Compilation `" + ' '.join([exe] + exe_flags) +
                  "` of source file `" + src_name +
                  "` exited with return code " + str(pt.comp_proc.returncode) +
                  ("`\n  - stdout:\n" + str(outs) if outs else "") +
                  ("`\n  - stderr:\n" + errs.decode('utf8') if errs else ""),
                  file=sys.stderr)
            if rss_mu and isinstance(rss_mu, (int, float)):
                if op == "Check":
                    row[CHECK_RSS_MU_IX] = rss_mu / (args.function_count * args.function_depth)
                if op == "Build":
                    row[BUILD_RSS_MU_IX] = rss_mu / (args.function_count * args.function_depth)
            return None

        durs.append(timer() - cstart)

        if outs:
            if not outs.startswith(b'/usr/bin/ld: warning'):
                print('stdout:', outs)
        if errs:
            if lang == 'Ada':
                errs = errs.lstrip(b'x86_64-linux-gnu-gcc-10 -c -Igenerated/ada/ -I- generated/ada/main.adb\n')
            if len(errs) and not errs.startswith(b'/usr/bin/ld: warning'):  # skip ld warning
                print('output:', errs)
    dur_min = min(durs)         # duration minimum

    # run
    run_dur_min = None             # run duration minimum
    if op == 'Build':
        outb = out_binary(lang)
        if runner:
            if runner is True:      # binary should be runnable
                if (exe.endswith('cproc')):  # cproc forgets to set executable bit
                    st = os.stat(exe)
                    os.chmod(outb, st.st_mode | stat.S_IEXEC)
                run_dur_min = run_compiled_file(exe)
            elif isinstance(runner, list):
                run_dur_min = run_compiled_file(runner + [outb])
        elif out_flag_and_exe:
            if runner is not False:
                print("TODO run " + outb + " using runner " + str(runner))

    show_file = False
    compiler_version_str = ' version ' + str(compiler_version) if compiler_version is not None else ''
    if show_file:
        print('- {} of {} took {:1.3f} seconds (using "{}"{})'.format(op, src_name, dur_min, exe,
                                                                      compiler_version_str))
    else:
        print('- {} took {:1.3f} seconds (using "{}"{})'.format(op, dur_min, exe,
                                                                compiler_version_str))

    table_row(row=row,
              args=args,
              lang=lang,
              op=op,
              exe_path=exe,
              compiler_version=compiler_version,
              check_dur=dur_min if op == 'Check' else None,
              compile_dur=dur_min if op == 'Compile' else None,
              build_dur=dur_min if op == 'Build' else None,
              run_dur=run_dur_min,
              check_rss_mu=rss_mu if op == 'Check' else None,
              build_rss_mu=rss_mu if op == 'Build' else None,
              templated=templated)


def run_compiled_file(args, run_count=1):
    durs = []                  # compilation durations
    for _ in range(0, run_count):
        cstart = timer()        # compilation start
        # print("args:", args)
        with sp.Popen(args,
                      stdout=sp.PIPE,
                      stderr=sp.PIPE) as comp_proc:
            outs, errs = comp_proc.communicate()
            # pprint(comp_proc.__dict__)
            # TODO detect segfault exit code
            # if comp_proc.returncode != 0:
            #     print("WARNING: Run of compiled exec `" + str(args) +
            #           "` exited with return code " + str(comp_proc.returncode),
            #           file=sys.stderr)
            #     return None
            durs.append(timer() - cstart)
    dur_min = min(durs)         # running duration minimum
    return dur_min


def long_types_of_lang(lang):
    if lang in ('c', 'c3', 'c++', 'c#', 'java'):
        return ['long']
    elif lang in ('rust', 'zig', 'v', 'vox', 'c3'):
        return ['i64']
    elif lang in 'swift':
        return ['Int64']
    elif lang == 'd':
        return ['long']
    elif lang in ('go', 'nim'):
        return ['int64']
    elif lang == 'julia':
        return ['Int64']
    elif lang == 'ocaml':
        return ['float']
    elif lang == 'ada':
        return ['Long_Integer']  # gnat
    else:
        return None


def language_file_extension(lang):
    if lang == 'rust':
        return 'rs'
    elif lang == 'julia':
        return 'jl'
    elif lang == 'ocaml':
        return 'ml'
    elif lang == 'c#':
        return 'cs'
    elif lang == 'vox':
        return 'vx'
    elif lang == 'ada':
        return 'adb'
    else:
        return lang


def generate_test_program_file(lang, args, templated, run_ix):
    program_name = DEFAULT_PROGRAM_NAME

    llang = lang.lower()        # lowered language
    types = long_types_of_lang(llang)
    ext = language_file_extension(llang)
    dir_path = os.path.join(ROOT_PATH, llang)
    os.makedirs(dir_path, exist_ok=True)

    path = (os.path.join(dir_path, program_name + ('_t' if templated else '') +
                         ('_' + str(run_ix) if lang.lower() != 'ada' else '') +
                         '.' + ext))

    start = timer()
    with open(path, 'w') as f:
        generate_test_language_specific_prefix(llang, program_name, f, templated=templated)

        if llang == 'ada':
            generate_test_main_header(llang, types, f, templated)
            generate_main_test_function_definition_set(llang, types, args, f,
                                                       templated=templated)
        else:
            generate_main_test_function_definition_set(llang, types, args, f,
                                                       templated=templated)
            generate_test_main_header(llang, types, f, templated)

        for typ in types:
            generate_main_test_function_variable(llang, typ, f, templated=templated)

        generate_test_main_middle(llang, types, f, templated)

        for typ in types:
            for findex in range(0, args.function_count):
                generate_test_function_call(llang, findex, typ, f, templated=templated)

        generate_test_language_specific_postfix(llang, types, f)
    end = timer()
    dur = (end - start)  # time dur
    print('- Generating {} took {:1.3f} seconds ({})'.format(path, dur, lang))

    return path


def generate_test_function_call(lang, findex, typ, f, templated):
    if lang in ('c#', 'java'):
        f.write('    ')

    if lang == 'zig' and templated:  # Zig needs explicit template type
        f.write(Tm('    ${T}_sum += add_${T}_n${N}(${T}, ${N})').substitute(T=typ, N=str(findex)))
    elif lang == 'v' and templated:  # Zig needs explicit template type for now. See: https://github.com/vlang/v/issues/5818
        f.write(Tm('    ${T}_sum += add_${T}_n${N}<${T}>(${N})').substitute(T=typ, N=str(findex)))
    elif lang == 'ocaml':
        f.write(Tm('    let ${T}_sum = ${T}_sum +. (add_${T}_n${N} ${N}.0) in').substitute(T=typ, N=str(findex)))
    elif lang == 'ada':
        f.write(Tm('   ${T}_sum := ${T}_sum + add_${T}_n${N}(${N})').substitute(T=typ, N=str(findex)))
    elif lang == 'vox':
        f.write(Tm('    ${T}_sum += add_${T}_n${N}${X}(${N})').substitute(T=typ,
                                                                          N=str(findex),
                                                                          X='[' + typ + ']' if templated else ''))
    elif lang == 'swift':
        f.write(Tm('    ${T}_sum += add_${T}_n${N}(x: ${N})').substitute(T=typ, N=str(findex)))
    else:
        f.write(Tm('    ${T}_sum += add_${T}_n${N}(${N})').substitute(T=typ, N=str(findex)))

    if lang not in ('ocaml', 'nim', 'v'):
        f.write(';')            # statement terminator

    f.write('\n')


def generate_test_language_specific_prefix(lang, program_name, f, templated):
    if lang == 'go':
        f.write('package ' + program_name + ';\n')
        f.write('// import ("os")\n\n')  # fails with `gotype`
    elif lang == 'rust':
        f.write('use std::process::exit;\n')
        if templated:
            f.write('use std::ops::Add;\n')
    elif lang == 'swift':
        f.write('import Foundation\n\n')
    elif lang == 'c#':
        f.write('using System;\n\n')
        f.write('public class HelloWorld {\n')
    elif lang == 'java':
        f.write('class HelloWorld {\n')
    elif lang == 'ada':
        f.write('with System;\n\n')
        f.write('with GNAT.OS_Lib;\n\n')
    elif lang == 'vox':
        f.write('''enum u32 stdin = 0;
enum u32 stdout = 1;
enum u32 stderr = 2;

@extern(syscall, 60)
void exit(i32 error_code);

@extern(syscall, 1)
void sys_write(u32 fd, u8* buf, u64 count);

void write(u32 fd, u8[] data) {
    sys_write(fd, data.ptr, data.length);
}
''')


def generate_test_language_specific_postfix(lang, types, f):
    if lang == 'rust':
        f.write(Tm('    exit((${T}_sum % 4294967296) as i32);\n}\n').substitute(T=types[0]))
    elif lang == 'd':
        f.write(Tm('    return cast(int)${T}_sum;\n}\n').substitute(T=types[0]))
    elif lang == 'nim':
        f.write(Tm('    quit(int(${T}_sum))\n\n').substitute(T=types[0]))
    elif lang == 'swift':
        f.write(Tm('    exit(Int32(${T}_sum))\n}\n').substitute(T=types[0]))
    elif lang == 'go':
        f.write(Tm('    // os.Exit(int(${T}_sum));\n').substitute(T=types[0]))
        f.write(Tm('}\n').substitute(T=types[0]))
    elif lang == 'c#':
        f.write(Tm('        Environment.Exit(${T}_sum == 42 ? 1 : 0);\n    }\n').substitute(T=types[0]))
    elif lang == 'java':
        f.write(Tm('        System.exit(${T}_sum == 42 ? 1 : 0);\n    }\n').substitute(T=types[0]))
    elif lang == 'zig':
        f.write(Tm('\n}\n').substitute(T=types[0]))
    elif lang == 'nim':
        f.write(Tm('\n\n').substitute(T=types[0]))
    elif lang == 'c3':
        f.write(Tm('\n}\n').substitute(T=types[0]))  # TODO exit
    elif lang == 'julia':
        f.write(Tm('''    return ${T}_sum;
end

main()
''').substitute(T=types[0]))
    elif lang == 'd':
        f.write(Tm('''    return cast(int)${T}_sum;
}
''').substitute(T=types[0]))
    elif lang == 'vox':
        # TODO: use exit(i32(${T}_sum)) when it doesnâ€™t segfault:
        f.write(Tm('''    exit(0);
    return 0;
}
''').substitute(T=types[0]))
    elif lang == 'ada':
        f.write(Tm('''   GNAT.OS_Lib.OS_Exit(Integer(${T}_sum));
end Main;
''').substitute(T=types[0]))
    elif lang == 'ocaml':
        f.write(Tm('    exit (if ${T}_sum = 42.0 then 1 else 0)\n').substitute(T=types[0]))
    elif lang == 'v':
        f.write(Tm('''    exit(int(${T}_sum >> 32))\n}\n''').substitute(T=types[0]))
    else:
        f.write(Tm('''    return ${T}_sum;\n}\n''').substitute(T=types[0]))

    if lang in ('c#', 'java'):
        f.write('}\n')            # one extra closing brace for class


def generate_main_test_function_definition_set(lang, types, args, f,
                                               templated):
    for typ in types:
        for findex in range(0, args.function_count):
            for fheight in range(0, args.function_depth):
                generate_test_function_definition(args, lang, typ, findex, fheight, f,
                                                  templated=templated)
            f.write('\n')
        f.write('\n')


def function_name(typ, findex, fheight):
    if fheight is not None:
        return Tm('add_${T}_n${N}_h${H}').substitute(T=typ,
                                                     N=str(findex),
                                                     H=str(fheight))
    else:
        return Tm('add_${T}_n${N}').substitute(T=typ,
                                               N=str(findex))


def generate_test_function_definition(args, lang, typ, findex, fheight, f,
                                      templated):
    if RANDOMIZE_FLAG:
        nconst = str(random.randint(0, 100000))
    else:
        nconst = str(findex)

    if fheight == 0:
        if lang == 'rust' and templated:
            expr = 'x'          # because Rust is picky
        elif lang == 'ocaml':
            expr = 'x +. ' + nconst + '.0'
        else:
            expr = 'x + ' + nconst
    else:
        if lang == 'zig' and templated:
            xtarg = typ + ', '  # Zig needs explicit template parameter
        else:
            xtarg = ''
        if lang == 'rust' and templated:
            call = function_name(typ, findex, fheight - 1) + '(' + xtarg + 'x)'
            expr = 'x + ' + call
        elif lang == 'v' and templated:
            call = function_name(typ, findex, fheight - 1) + Tm('<${T}>(x)').substitute(T=typ)
            expr = 'x + ' + call
        elif lang == 'vox' and templated:
            call = function_name(typ, findex, fheight - 1) + Tm('[${T}](x)').substitute(T=typ)
            expr = 'x + ' + call
        elif lang == 'ocaml':
            expr = 'x +. (' + function_name(typ, findex, fheight - 1) + xtarg + ' x) +. ' + nconst + '.0'
        elif lang == 'swift':
            expr = 'x + ' + function_name(typ, findex, fheight - 1) + '(x: ' + xtarg + 'x) + ' + nconst
        else:
            expr = 'x + ' + function_name(typ, findex, fheight - 1) + '(' + xtarg + 'x) + ' + nconst

    if fheight == args.function_depth - 1:
        fname = function_name(typ, findex, fheight=None)
    else:
        fname = function_name(typ, findex, fheight)

    if lang in ('c'):
        f.write(Tm('${T} ${F}(${T} x) { return ${X}; }\n').substitute(T=typ, F=str(fname), N=nconst, X=expr))
    elif lang in ('c3'):
        f.write(Tm('func ${T} ${F}(${T} x) { return ${X}; }\n').substitute(T=typ, F=str(fname), N=nconst, X=expr))
    elif lang in ['ada']:
        f.write(Tm('''   function ${F} (x: ${T}) return ${T} is (${X});
''').substitute(T=typ, F=str(fname), N=nconst, X=expr))
    elif lang in ['c#']:
        f.write(Tm('    static ${T} ${F}(${T} x) { return ${X}; }\n').substitute(T=typ, F=str(fname), N=nconst, H=str(fheight), X=expr))
    elif lang in ['java']:
        f.write(Tm('    static ${T} ${F}(${T} x) { return ${X}; }\n').substitute(T=typ, F=str(fname), N=nconst, H=str(fheight), X=expr))
    elif lang in ['c++']:
        f.write(Tm('${M}${T} ${F}(${T} x) { return ${X}; }\n')
                .substitute(T=typ, F=str(fname), N=nconst, H=str(fheight),
                            M='template<typename T=int> ' if templated else '',
                            X=expr))
        # template<typename T1, typename T2 = int> class A;
    elif lang in ('d', 'vox'):
        # See: https://forum.dlang.org/post/sfldpxiieahuiizvgjeb@forum.dlang.org
        f.write(Tm('${T} ${F}${M}(${T} x)${Q} { return ${X}; }\n')
                .substitute(T='T' if templated else typ,
                            F=str(fname),
                            N=nconst,
                            H=str(fheight),
                            M=('(T)' if lang == 'd' else '[T]') if templated else '',
                            Q=' @safe pure nothrow @nogc' if lang == 'd' else '',
                            X=expr))
    elif lang == 'rust':
        if templated:
            f.write(Tm('fn ${F}<${T} : ${R}>(x: ${T}) -> ${T} { ${X} }\n').substitute(T='T',
                                                                                      R='Copy + Add<Output = T>',
                                                                                      F=str(fname),
                                                                                      N=nconst,
                                                                                      H=str(fheight),
                                                                                      X=expr))
        else:
            f.write(Tm('fn ${F}(x: ${T}) -> ${T} { ${X} }\n').substitute(T=typ, F=str(fname), N=nconst, H=str(fheight), X=expr))
    elif lang == 'swift':
        if templated:
            f.write(Tm('func ${F}<${T}>(x: ${T}) -> ${T} { return ${X} }\n').substitute(T='T',
                                                                                        F=str(fname),
                                                                                        N=nconst,
                                                                                        H=str(fheight),
                                                                                        X=expr))
        else:
            f.write(Tm('func ${F}(x: ${T}) -> ${T} { return ${X} }\n').substitute(T=typ, F=str(fname), N=nconst, H=str(fheight), X=expr))
    elif lang == 'nim':
        if templated:
            f.write(Tm('proc ${F}<${T}>(x: ${T}): ${T} =\n  return ${X}\n').substitute(T='T',
                                                                                       F=str(fname),
                                                                                       N=nconst,
                                                                                       H=str(fheight),
                                                                                       X=expr))
        else:
            f.write(Tm('proc ${F}(x: ${T}): ${T} = \n  return ${X}\n').substitute(T=typ, F=str(fname), N=nconst, H=str(fheight), X=expr))
    elif lang == 'c3':
        if templated:
            f.write(Tm('func ${F}<${T}>(x: ${T}) -> ${T} { return ${X} }\n').substitute(T='T',
                                                                                        F=str(fname),
                                                                                        N=nconst,
                                                                                        H=str(fheight),
                                                                                        X=expr))
        else:
            f.write(Tm('func ${T} ${F}(${T} x) { return ${X} }\n').substitute(T=typ, F=str(fname), N=nconst, H=str(fheight), X=expr))
    elif lang == 'zig':
        if templated:
            f.write(Tm('fn ${F}(comptime T: type, x: T) T { return ${X}; }\n').substitute(T=typ, F=str(fname), N=nconst, H=str(fheight), X=expr))
        else:
            f.write(Tm('fn ${F}(x: ${T}) ${T} { return ${X}; }\n').substitute(T=typ, F=str(fname), N=nconst, H=str(fheight), X=expr))
    elif lang == 'go':
        f.write(Tm('func ${F}(x ${T}) ${T} { return ${X} }\n').substitute(T=typ, F=str(fname), N=nconst, H=str(fheight), X=expr))
    elif lang == 'ocaml':
        f.write(Tm('let ${F} x = ${X}\n').substitute(F=str(fname), X=expr))
    elif lang == 'v':
        if templated:
            f.write(Tm('fn ${F}<${T}>(x ${T}) ${T} { return ${X} }\n').substitute(T='T', F=str(fname), N=nconst, H=str(fheight), X=expr))
        else:
            f.write(Tm('fn ${F}(x ${T}) ${T} { return ${X} }\n').substitute(T=typ, F=str(fname), N=nconst, H=str(fheight), X=expr))
    elif lang == 'julia':
        f.write(Tm('function ${F}(x${QT})${QT}\n    return ${X}\nend;\n').substitute(QT=('' if templated else ('::' + typ)),
                                                                                     F=str(fname), N=nconst, H=str(fheight), X=expr))


def generate_test_main_header(lang, types, f, templated):
    if lang in ['c', 'c++']:
        # `cproc` cannot handle this skip for now:
        # f.write('int main(__attribute__((unused)) int argc, __attribute__((unused)) char* argv[]) {\n')
        f.write('int main(void) {\n')
    elif lang == 'ada':
        f.write('procedure Main is\n')
    elif lang == 'c#':
        f.write('    public static void Main(string[] args) {\n')
    elif lang == 'java':
        f.write('    public static void main(String args[]) {\n')
    elif lang == 'd':
        f.write('int main() @safe {\n')
    elif lang == 'vox':
        f.write('i32 main() {\n')
    elif lang == 'rust':
        f.write(Tm('fn main() {\n').substitute(T=types[0]))
    elif lang == 'swift':
        f.write(Tm('func main() {\n').substitute(T=types[0]))
    elif lang == 'zig':
        f.write(Tm('pub fn main() void {\n').substitute(T=types[0]))
    elif lang == 'c3':
        f.write(Tm('func void main() {\n').substitute(T=types[0]))
    elif lang == 'go':
        f.write(Tm('func main() {\n').substitute(T=types[0]))
    elif lang == 'v':
        f.write(Tm('fn main() {\n').substitute(T=types[0]))
    elif lang == 'julia':
        f.write(Tm('function main()${QT}\n').substitute(QT=(('::' + types[0]) if templated else '')))
    elif lang == 'ocaml':
        f.write('let () = \n')
    elif lang == 'nim':
        f.write('when isMainModule:\n')
    else:
        assert False


def generate_test_main_middle(lang, types, f, templated):
    if lang == 'ada':
        f.write('begin\n')


def generate_main_test_function_variable(lang, typ, f, templated):
    if lang in ('c', 'c3', 'c++', 'd', 'vox'):
        f.write(Tm('    ${T} ${T}_sum = 0;\n').substitute(T=typ))
    elif lang in ['ada']:
        f.write(Tm('   ${T}_sum : ${T} := 0;\n').substitute(T=typ))
    elif lang in ['c#']:
        f.write(Tm('        ${T} ${T}_sum = 0;\n').substitute(T=typ))
    elif lang in ['java']:
        f.write(Tm('        ${T} ${T}_sum = 0;\n').substitute(T=typ))
    elif lang == 'rust':
        f.write(Tm('    let mut ${T}_sum : ${T} = 0;\n').substitute(T=typ))
    elif lang == 'swift':
        f.write(Tm('    var ${T}_sum: ${T} = 0;\n').substitute(T=typ))
    elif lang == 'nim':
        f.write(Tm('    var ${T}_sum: ${T} = 0;\n').substitute(T=typ))
    elif lang == 'zig':
        f.write(Tm('    var ${T}_sum: ${T} = 0;\n').substitute(T=typ))
    elif lang == 'go':
        f.write(Tm('    var ${T}_sum ${T} = 0;\n').substitute(T=typ))
    elif lang == 'v':
        f.write(Tm('    mut ${T}_sum := ${T}(0)\n').substitute(T=typ))
    elif lang == 'julia':
        f.write(Tm('    ${T}_sum${QT} = 0;\n').substitute(T=typ, QT=(('::' + typ) if templated else '')))
    elif lang == 'ocaml':
        f.write(Tm('    let ${T}_sum = 0.0 in\n').substitute(T=typ))
    else:
        assert False


def generate_test_program_2(function_count, lang, templated):
    program_name = 'sample2'

    lang = lang.lower()
    types = long_types_of_lang(lang)
    ext = language_file_extension(lang)
    dir_path = os.path.join(ROOT_PATH, lang)
    os.makedirs(dir_path, exist_ok=True)
    path = os.path.join(dir_path, program_name + '.' + ext)

    start = timer()
    with open(path, 'w') as f:

        # package definition
        if lang == 'go':
            f.write('''package ''' + program_name + ''';

''')

        # standard io module
        if lang in ['c']:
            f.write('''#include <stdio.h>
''')
        if lang in ['c++']:
            f.write('''#include <iostream>
''')
        if lang in ('d', 'vox'):
            f.write('''import std.stdio;
''')
        if lang == 'rust':
            f.write('''use std::io;
''')
        if lang == 'c3':
            f.write('''import std::io;
''')
        if lang == 'go':
            f.write('''import "fmt";

''')
        if lang == 'v':
            f.write('''import os
''')

        # special modules
        if lang == 'rust':
            f.write('''use std::process::exit;
''')

        for typ in types:
            for findex in range(0, function_count):
                if lang in ('c', 'c3', 'c++'):
                    f.write(Tm('''${T} add_${T}_n${N}(${T} x) { return x + ${N}; }
''').substitute(T=typ, N=str(findex)))
                if lang in ('d', 'vox'):
                    f.write(Tm('''${T} add_${T}_n${N}(${T} x) pure { return x + ${N}; }
''').substitute(T=typ, N=str(findex)))
                elif lang == 'rust':
                    f.write(Tm('''fn add_${T}_n${N}(x: ${T}) -> ${T} { x + ${N} }
''').substitute(T=typ, N=str(findex)))
                elif lang == 'zig':
                    f.write(Tm('''fn add_${T}_n${N}(x: ${T}) ${T} { return x + ${N}; }
''').substitute(T=typ, N=str(findex)))
                elif lang == 'go':
                    f.write(Tm('''func add_${T}_n${N}(x ${T}) ${T} { return x + ${N} }
''').substitute(T=typ, N=str(findex)))
                elif lang == 'ocaml':
                    f.write(Tm('''let add_${T}_n${N} x = x +. ${N}.0
''').substitute(T=typ, N=str(findex)))
                elif lang == 'v':
                    f.write(Tm('''fn add_${T}_n${N}(x ${T}) ${T} { return x + ${N} }
''').substitute(T=typ, N=str(findex)))
                elif lang == 'julia':
                    f.write(Tm('''function add_${T}_n${N}(x${QT})${QT}
    return x + ${N}
end;
''').substitute(QT=('' if templated else ('::' + typ)), N=str(findex)))
                    f.write('\n')

        # MAIN HEADER
        if lang in ['c', 'c++']:
            f.write('''int main(__attribute__((unused)) int argc, __attribute__((unused)) char* argv[])
{
''')
        elif lang in ('d', 'vox'):
            f.write('''int main(string[] args)
{
''')
        elif lang == 'rust':
            f.write(Tm('''fn main() {
''').substitute(T=types[0]))
        elif lang == 'zig':
            f.write(Tm('''pub fn main() void {
''').substitute(T=types[0]))
        elif lang == 'go':
            f.write(Tm('''func main() ${T} {
''').substitute(T=types[0]))
        elif lang == 'v':
            f.write(Tm('''fn main() ${T} {
''').substitute(T=types[0]))
        elif lang == 'julia':
            f.write(Tm('''function main()::${T}
''').substitute(T=types[0]))
        else:
            assert False

        # CALCULATE
        for typ in types:
            if lang in ('c', 'c3', 'c++', 'd', 'vox'):
                f.write(Tm('''    ${T} ${T}_sum = 0;
''').substitute(T=typ))
            elif lang == 'rust':
                f.write(Tm('''    let mut ${T}_sum : ${T} = 0;
''').substitute(T=typ))
            elif lang == 'zig':
                f.write(Tm('''    var ${T}_sum: ${T} = 0;
''').substitute(T=typ))
            elif lang == 'go':
                f.write(Tm('''    var ${T}_sum ${T} = 0;
''').substitute(T=typ))
            elif lang == 'v':
                f.write(Tm('''    var ${T}_sum ${T} = 0;
''').substitute(T=typ))
            elif lang == 'julia':
                f.write(Tm('''    ${T}_sum${QT} = 0;
''').substitute(QT=('' if templated else ('::' + typ))))
            else:
                assert False

            for findex in range(0, function_count):
                f.write(Tm('''    ${T}_sum += add_${T}_n${N}(${N});
''').substitute(T=typ, N=str(findex)))

        if lang == 'rust':
            f.write(Tm('''    exit(${T}_sum);
}
''').substitute(T=types[0]))
        elif lang == 'zig':
            f.write(Tm('''
}
''').substitute(T=types[0]))
        elif lang == 'ocaml':
            f.write(Tm('''    ${T}_sum''').substitute(T=types[0]))
        elif lang == 'julia':
            f.write(Tm('''    return ${T}_sum;
end

main()
''').substitute(T=types[0]))
        elif lang in ('d', 'vox'):
            f.write(Tm('''    return cast(int)${T}_sum;
}
''').substitute(T=types[0]))
        else:
            f.write(Tm('''    return ${T}_sum;
}
''').substitute(T=types[0]))

    end = timer()
    dur = (end - start)  # time dur
    print('- Generating {} took {:1.3f} seconds ({})'.format(path, dur, lang))

    return path


if __name__ == '__main__':
    main()
