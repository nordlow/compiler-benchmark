#!/usr/bin/env python3

import sys
import argparse
import subprocess as sp
import os
import stat
import os.path
from shutil import which
import time
from pprint import pprint
import random
from datetime import datetime
from os.path import expanduser

from string import Template as Tm
from timeit import default_timer as timer

from process_timer import ProcessTimer

SUPPORTED_LANGUAGES = ['C', 'C++', 'Ada', 'C#', 'Swift', 'Java', 'D', 'Vox', 'Rust', 'Nim', 'Zig', 'Go', 'V', 'C3', 'Julia', 'OCaml']
TEMPLATED_SUPPORTED_LANGUAGES = ['C++', 'Java', 'D', 'Swift', 'Vox', 'Rust', 'Zig', 'V', 'C3', 'Julia']
SUPPORTED_OPERATIONS = ['Check', 'Build']
DEFAULT_PROGRAM_NAME = 'main'

C_WARN_FLAGS = ['-Wall', '-Wextra', '-Wno-c++11-extensions']

RUSTC_NO_WARNINGS_FLAGS = ['-A', 'warnings']  # flags that disable warnings for `rustc`
RUSTC_FLAGS = []          # set to `RUSTC_NO_WARNINGS_FLAGS` to disable warnings

ROOT_PATH = 'generated'
RANGE = range(5, 15)
VERSIONS = [""] + [f"-{i}" for i in RANGE]

HOME = os.path.expanduser("~")  # instead of home = os.getenv('HOME') that doesnâ€™t work on Windows

TABLE_TITLES = ['Lang-uage', 'Temp-lated', 'Check Time [us/func]', 'Build Time [us/func]', 'Run Time [us/func]', 'RSS Mem Max Usage', 'Exec Version', 'Exec Path']
LANG_IX = 0
TEMPLATED_IX = 1
CDUR_PER_FUNC_IX = 2       # check duration
BDUR_PER_FUNC_IX = 3       # build duration
RDUR_PER_FUNC_IX = 4       # run duration
RSS_MU_IX = 5              # RSS memory usage
EXE_VERSION_IX = 6
EXE_PATH_IX = 7
TABLE_LENGTH = EXE_PATH_IX + 1

assert len(TABLE_TITLES) == TABLE_LENGTH

def table_row(args, lang, op, exe_path, compiler_version, cdur, bdur, rdur, rss_mu, templated):
    if exe_path.startswith(HOME):
        exe_path = os.path.join('~', exe_path.lstrip(HOME))

    row = [None] * TABLE_LENGTH  # preallocate
    row[LANG_IX] = lang
    row[TEMPLATED_IX] = 'Yes' if templated else 'No'

    if cdur is not None:
        row[CDUR_PER_FUNC_IX] = cdur / (args.function_count * args.function_depth)

    if bdur is not None:
        row[BDUR_PER_FUNC_IX] = bdur / (args.function_count * args.function_depth)

    if rdur is not None:
        row[RDUR_PER_FUNC_IX] = rdur / (args.function_count * args.function_depth)

    row[RSS_MU_IX] = memory_usage_str(rss_mu)

    row[EXE_VERSION_IX] = compiler_version
    row[EXE_PATH_IX] = '`' + os.path.basename(exe_path) + '`'

    return row

RANDOMIZE_FLAG = True

if RANDOMIZE_FLAG:
    random.seed(str(datetime.now()))


def get_version(version_run):
    return next(part
                for part
                in version_run.stdout.decode('utf-8').split()
                if (part[0].isdigit() or
                    part[0] == 'v' and part[1].isdigit())) # v2.096.1-beta.1-187-gb25be89b3


def touchFile(path):
    with open(path, 'a'):
        os.utime(path, None)


def ate_D_object_file():
    path = os.path.join(ROOT_PATH, 'd', 'object.d')
    touchFile(path=path)
    return path


def out_binary(lang):
    return os.path.join(ROOT_PATH,
                        lang.lower(),
                        DEFAULT_PROGRAM_NAME)


def srcIdOf(lang, templated):
    if lang in TEMPLATED_SUPPORTED_LANGUAGES:
        return lang + ('-Templated' if templated else '-Untemplated')
    else:
        return lang


def opIdOf(lang, templated, op, exe_path):
    return srcIdOf(lang, templated) + '-' + op + '-' + str(exe_path)


def fill_in_speedups(results, column_ix):
    # calculate minimum
    min_ix = None               # index of minimum
    min_dur = None              # duration of minimum
    for ix, result in enumerate(results):
        if min_dur is None or (result[column_ix] is not None and
                               min_dur > result[column_ix]):
            min_ix = ix
            min_dur = result[column_ix]
    min_lang = results[min_ix][LANG_IX]  # language of minimum

    for ix, result in enumerate(results):
        result[column_ix] = stringify_metrics(abs_n=result[column_ix],
                                              min_dur=min_dur,
                                              column_ix=column_ix,
                                              min_lang=min_lang)


def stringify_metrics(abs_n, min_dur, column_ix, min_lang):
    if abs_n is None:
        return '{:>6}'.format('N/A')
    rel_n = abs_n / min_dur
    if column_ix == CDUR_PER_FUNC_IX:
        return to_str_in_microseconds(abs_n) + " (" + factor_str(rel_n) + " " + min_lang + ")"
    elif column_ix == BDUR_PER_FUNC_IX:
        return to_str_in_microseconds(abs_n) + " (" + factor_str(rel_n) + " " + min_lang + ")"
    elif column_ix == RDUR_PER_FUNC_IX:
        return to_str_in_nanoseconds(abs_n) + " (" + factor_str(rel_n) + " " + min_lang + ")"


def to_str_in_microseconds(dur):
    return '{:6.1f}'.format(1e6 * dur)


def to_str_in_nanoseconds(dur):
    return '{:.0f}'.format(1e9 * dur) if dur is not None else ''


def factor_str(factor):
    return '{:5.1f}'.format(factor)


def memory_usage_str(mu):
    if mu is None:
        return '{:>16}'.format('sample miss')
    return '{:16,}'.format(mu)


def repeat_to_length(string_to_expand, length):
    return (string_to_expand * (int(length / len(string_to_expand)) + 1))[:length]


def markdown_header(text, nr):        # Markdown header
    return '#' * nr + ' ' + text


def markdown_table(titles, rows):
    fill_in_speedups(results=rows, column_ix=CDUR_PER_FUNC_IX)
    fill_in_speedups(results=rows, column_ix=BDUR_PER_FUNC_IX)
    fill_in_speedups(results=rows, column_ix=RDUR_PER_FUNC_IX)

    result = ''

    result += '| '
    for col in titles:
        result += str(col) + ' | '
    result += '\n'

    result += '| '
    for ix, col in enumerate(range(len(titles))):
        if ix == TEMPLATED_IX:
            result += repeat_to_length("-", len(titles[ix])) + ' | '
        else:
            result += ':' + repeat_to_length("-", len(titles[ix]) - 2) + ':' + ' | '
    result += '\n'

    for row in rows:
        result += '| '
        for ix, cl in enumerate(range(len(titles))):
            col = row[ix]
            result += str(col) + repeat_to_length(" ", len(titles[ix]) - len(str(col))) + ' | '
        result += '\n'
    return result


def main():
    parser = argparse.ArgumentParser(formatter_class=argparse.ArgumentDefaultsHelpFormatter)

    parser.add_argument('--languages', '--langs', type=str,
                        default=','.join(SUPPORTED_LANGUAGES),
                        help='Languages to benchmark separated by comma')

    parser.add_argument('--operations', '--ops', type=str,
                        default=','.join(SUPPORTED_OPERATIONS),
                        help='Operations to perform separated by comma')

    parser.add_argument('--function-count', '--fc', type=int,
                        default=100,
                        help='Number of functions generated and called')

    parser.add_argument('--function-depth', '--fd', type=int,
                        default=100,
                        help='Function call depth')

    parser.add_argument('--run-count', '--rc', type=int,
                        default=1,
                        help='Number of runs for each compilation')

    args = parser.parse_args()

    args.languages = list(map(lambda x: 'OCaml' if x.lower() == 'ocaml' else x.capitalize(),
                              args.languages.split(',')))  # into a list
    filtered_languages = []
    for language in args.languages:
        if language in SUPPORTED_LANGUAGES:
            filtered_languages.append(language)
        else:
            print('Warning: Ignoring unsupported language ' + language)
    args.languages = filtered_languages

    args.operations = list(map(lambda x: x.capitalize(), args.operations.split(',')))  # into a list of capitalized names
    filtered_operations = []
    for operation in args.operations:
        if operation in SUPPORTED_OPERATIONS:
            filtered_operations.append(operation)
        else:
            print('Warning: Ignoring unsupported operation ' + operation)
    args.operations = filtered_operations

    gpaths = generate_code(args=args)

    execs = {}                  # execs by language
    durs = {}                   # time durs by compiler path

    results = []

    print(markdown_header('Benchmark:', 1))

    if 'D' in args.languages:
        if 'Check' in args.operations:
            results += benchmark_D(execs=execs, durs=durs, gpaths=gpaths, args=args, op='Check', templated=False, use_dips=True)
            results += benchmark_D(execs=execs, durs=durs, gpaths=gpaths, args=args, op='Check', templated=True, use_dips=True)
        if 'Build' in args.operations:
            results += benchmark_D(execs=execs, durs=durs, gpaths=gpaths, args=args, op='Build', templated=False, use_dips=True)
            results += benchmark_D(execs=execs, durs=durs, gpaths=gpaths, args=args, op='Build', templated=True, use_dips=True)

    if 'Vox' in args.languages:
        if 'Check' in args.operations:
            results += benchmark_Vox(execs=execs, durs=durs, gpaths=gpaths, args=args, op='Check', templated=False)
            results += benchmark_Vox(execs=execs, durs=durs, gpaths=gpaths, args=args, op='Check', templated=True)
        if 'Build' in args.operations:
            results += benchmark_Vox(execs=execs, durs=durs, gpaths=gpaths, args=args, op='Build', templated=False)
            results += benchmark_Vox(execs=execs, durs=durs, gpaths=gpaths, args=args, op='Build', templated=True)

    if 'C' in args.languages:
        if 'Check' in args.operations:
            results += benchmark_C_using_tcc(lang='C', execs=execs, durs=durs, gpaths=gpaths, args=args, op='Check', templated=False)
            results += benchmark_C_and_Cxx_using_gcc(lang='C', execs=execs, durs=durs, gpaths=gpaths, args=args, op='Check', templated=False)
            results += benchmark_C_and_Cxx_using_clang(lang='C', execs=execs, durs=durs, gpaths=gpaths, args=args, op='Check', templated=False)
            results += benchmark_C_using_cproc(lang='C', execs=execs, durs=durs, gpaths=gpaths, args=args, op='Check', templated=False)
        if 'Build' in args.operations:
            results += benchmark_C_using_tcc(lang='C', execs=execs, durs=durs, gpaths=gpaths, args=args, op='Build', templated=False)
            results += benchmark_C_and_Cxx_using_gcc(lang='C', execs=execs, durs=durs, gpaths=gpaths, args=args, op='Build', templated=False)
            results += benchmark_C_and_Cxx_using_clang(lang='C', execs=execs, durs=durs, gpaths=gpaths, args=args, op='Build', templated=False)
            results += benchmark_C_using_cproc(lang='C', execs=execs, durs=durs, gpaths=gpaths, args=args, op='Build', templated=False)

    if 'C++' in args.languages:
        if 'Check' in args.operations:
            results += benchmark_C_and_Cxx_using_gcc(lang='C++', execs=execs, durs=durs, gpaths=gpaths, args=args, op='Check', templated=False)
            results += benchmark_C_and_Cxx_using_clang(lang='C++', execs=execs, durs=durs, gpaths=gpaths, args=args, op='Check', templated=False)
            results += benchmark_C_and_Cxx_using_gcc(lang='C++', execs=execs, durs=durs, gpaths=gpaths, args=args, op='Check', templated=True)
            results += benchmark_C_and_Cxx_using_clang(lang='C++', execs=execs, durs=durs, gpaths=gpaths, args=args, op='Check', templated=True)
        if 'Build' in args.operations:
            results += benchmark_C_and_Cxx_using_gcc(lang='C++', execs=execs, durs=durs, gpaths=gpaths, args=args, op='Build', templated=False)
            results += benchmark_C_and_Cxx_using_clang(lang='C++', execs=execs, durs=durs, gpaths=gpaths, args=args, op='Build', templated=False)
            results += benchmark_C_and_Cxx_using_gcc(lang='C++', execs=execs, durs=durs, gpaths=gpaths, args=args, op='Build', templated=True)
            results += benchmark_C_and_Cxx_using_clang(lang='C++', execs=execs, durs=durs, gpaths=gpaths, args=args, op='Build', templated=True)

    if 'Ada' in args.languages:
        # if 'Check' in args.operations:
        #     results += benchmark_Ada_using_gcc(lang='Ada', execs=execs, durs=durs, gpaths=gpaths, args=args, op='Check', templated=False)
        if 'Build' in args.operations:
            results += benchmark_Ada_using_gcc(lang='Ada', execs=execs, durs=durs, gpaths=gpaths, args=args, op='Build', templated=False)

    if 'Go' in args.languages:
        if 'Check' in args.operations:
            results += benchmark_Go(execs=execs, durs=durs, gpaths=gpaths, args=args, op='Check', templated=False)
        if 'Build' in args.operations:
            results += benchmark_Go(execs=execs, durs=durs, gpaths=gpaths, args=args, op='Build', templated=False)

    if 'Swift' in args.languages:
        if 'Check' in args.operations:
            results += benchmark_Swift(execs=execs, durs=durs, gpaths=gpaths, args=args, op='Check', templated=False)
        if 'Build' in args.operations:
            results += benchmark_Swift(execs=execs, durs=durs, gpaths=gpaths, args=args, op='Build', templated=False)

    if 'V' in args.languages:
        if 'Build' in args.operations:
            results += benchmark_V(execs=execs, durs=durs, gpaths=gpaths, args=args, op='Build', templated=False)
            results += benchmark_V(execs=execs, durs=durs, gpaths=gpaths, args=args, op='Build', templated=True)

    if 'C3' in args.languages:
        if 'Build' in args.operations:
            results += benchmark_C3(execs=execs, durs=durs, gpaths=gpaths, args=args, op='Build', templated=False)

    if 'Zig' in args.languages:
        if 'Check' in args.operations:
            results += benchmark_Zig(execs=execs, durs=durs, gpaths=gpaths, args=args, op='Check', templated=False)
            results += benchmark_Zig(execs=execs, durs=durs, gpaths=gpaths, args=args, op='Check', templated=True)
        if 'Build' in args.operations:
            results += benchmark_Zig(execs=execs, durs=durs, gpaths=gpaths, args=args, op='Build', templated=False)
            results += benchmark_Zig(execs=execs, durs=durs, gpaths=gpaths, args=args, op='Build', templated=True)

    if 'Rust' in args.languages:
        if 'Check' in args.operations:
            results += benchmark_Rust(execs=execs, durs=durs, gpaths=gpaths, args=args, op='Check', templated=False)
            results += benchmark_Rust(execs=execs, durs=durs, gpaths=gpaths, args=args, op='Check', templated=True)
        if 'Build' in args.operations:
            results += benchmark_Rust(execs=execs, durs=durs, gpaths=gpaths, args=args, op='Build', templated=False)
            results += benchmark_Rust(execs=execs, durs=durs, gpaths=gpaths, args=args, op='Build', templated=True)

    if 'Nim' in args.languages:
        if 'Check' in args.operations:
            results += benchmark_Nim(execs=execs, durs=durs, gpaths=gpaths, args=args, op='Check', templated=False)
        if 'Build' in args.operations:
            results += benchmark_Nim(execs=execs, durs=durs, gpaths=gpaths, args=args, op='Build', templated=False)
            results += benchmark_Nim(execs=execs, durs=durs, gpaths=gpaths, args=args, op='Build', templated=True)

    if 'C#' in args.languages:
        if 'Build' in args.operations:
            results += benchmark_Mono(execs=execs, durs=durs, gpaths=gpaths, args=args, op='Build', templated=False)

    if 'Java' in args.languages:
        if 'Build' in args.operations:
            results += benchmark_Java(execs=execs, durs=durs, gpaths=gpaths, args=args, op='Build', templated=False)

    if 'Julia' in args.languages:
        if 'Build' in args.operations:
            if args.function_count * args.function_depth >= 10000: # takes too long otherwise
                # participate by truncating size because ops/function are measured
                args.function_count = 100
                args.function_depth = 100
            results += benchmark_Julia(execs=execs, durs=durs, gpaths=gpaths, args=args, op='Build', templated=False)
            results += benchmark_Julia(execs=execs, durs=durs, gpaths=gpaths, args=args, op='Build', templated=True)

    if 'OCaml' in args.languages:
        if 'Build' in args.operations:
            if args.function_count * args.function_depth >= 10000: # takes too long otherwise
                # participate by truncating size because ops/function are measured
                args.function_count = 100
                args.function_depth = 100
            results += benchmark_OCaml(execs=execs, durs=durs, gpaths=gpaths, args=args, op='Build', templated=False, bytecode=True)

    print()

    print(markdown_table(TABLE_TITLES, results))


def generate_code(args):
    print(markdown_header('Code-generation:', 1))
    gpaths = {}
    for lang in args.languages:
        templated = False
        gpaths[srcIdOf(lang, templated)] = generate_test_program(lang=lang,
                                                                 args=args,
                                                                 templated=templated)
        if lang in TEMPLATED_SUPPORTED_LANGUAGES:
            templated = True
            gpaths[srcIdOf(lang, templated)] = generate_test_program(lang=lang,
                                                                     args=args,
                                                                     templated=templated)
    print()
    return gpaths


def benchmark_Ada_using_gcc(lang, execs, durs, gpaths, args, op, templated):
    results = list()
    comp_flags = ['compile'] if op == 'Build' else ['check']
    for gcc_version in VERSIONS:
        exe = which('gnat' + str(gcc_version))
        if exe is not None:
            version = get_version(sp.run([exe, '--version'], stdout=sp.PIPE))
            compile_file(src_paths=[gpaths[srcIdOf(lang, templated)]],
                         out_flag_and_exe=['-o', out_binary(lang)],
                         exe=exe,
                         runner=True,
                         comp_flags=comp_flags,
                         args=args,
                         op=op,
                         compiler_version=version,
                         lang=lang,
                         templated=templated,
                         results=results,
                         durs=durs)
    return results


def benchmark_C_and_Cxx_using_gcc(lang, execs, durs, gpaths, args, op, templated):
    results = list()
    comp_flags = [] if op == 'Build' else ['-fsyntax-only']
    for gcc_version in VERSIONS:
        if lang == 'C':
            exe = which('gcc' + str(gcc_version))
        elif lang == 'C++':
            exe = which('g++' + str(gcc_version))
        else:
            assert(False)
        if exe is not None:
            version = sp.run([exe, '--version'], stdout=sp.PIPE).stdout.decode('utf-8').split()[2].split('-')[0]
            compile_file(src_paths=[gpaths[srcIdOf(lang, templated)]],
                         out_flag_and_exe=['-o', out_binary(lang)],
                         exe=exe,
                         runner=True,
                         comp_flags=C_WARN_FLAGS + comp_flags,
                         args=args,
                         op=op,
                         compiler_version=version,
                         lang=lang,
                         templated=templated,
                         results=results,
                         durs=durs)
    return results


def benchmark_C_using_cproc(lang, execs, durs, gpaths, args, op, templated):
    results = list()

    exe = which('cproc')
    if op == 'Check':
        comp_flags = ['-emit-qbe']
        out_flag_and_exe = ['-o', '/dev/null']
    elif op == 'Build':
        comp_flags = [] # TODO add version that skips linking via: comp_flags = ['-c']
        out_flag_and_exe = ['-o', out_binary(lang)]
    else:
        assert(False)

    if exe is not None:
        version = 'unknown'
        compile_file(src_paths=[gpaths[srcIdOf(lang, templated)]],
                     out_flag_and_exe=out_flag_and_exe,
                     exe=exe,
                     runner=(op == 'Build'),
                     comp_flags=comp_flags,
                     args=args,
                     op=op,
                     compiler_version=version,
                     lang=lang,
                     templated=templated,
                     results=results,
                     durs=durs)
    return results


def benchmark_C_using_tcc(lang, execs, durs, gpaths, args, op, templated):
    results = list()

    exe = which('tcc')
    if op == 'Check':
        comp_flags = ['-c']
        out_flag_and_exe = ['-o', '/dev/null']
    elif op == 'Build':
        comp_flags = [] # TODO add version that skips linking via: comp_flags = ['-c']
        out_flag_and_exe = ['-o', out_binary(lang)]
    else:
        assert(False)

    if exe is not None:
        version = get_version(sp.run([exe, '-v'], stdout=sp.PIPE))
        compile_file(src_paths=[gpaths[srcIdOf(lang, templated)]],
                     out_flag_and_exe=out_flag_and_exe,
                     exe=exe,
                     runner=(op == 'Build'),
                     comp_flags=comp_flags,
                     args=args,
                     op=op,
                     compiler_version=version,
                     lang=lang,
                     templated=templated,
                     results=results,
                     durs=durs)
    return results


def benchmark_C_and_Cxx_using_clang(lang, execs, durs, gpaths, args, op, templated):
    results = list()
    C_CLANG_FLAGS = C_WARN_FLAGS + ['-fno-color-diagnostics', '-fno-caret-diagnostics', '-fno-diagnostics-show-option']
    comp_flags = [] if op == 'Build' else ['-fsyntax-only']
    for clang_version in VERSIONS:
        if lang == 'C':
            exe = which('clang' + str(clang_version))
        elif lang == 'C++':
            exe = which('clang++' + str(clang_version))
        else:
            assert(False)
        if exe is not None:
            version = get_version(sp.run([exe, '--version'], stdout=sp.PIPE))
            compile_file(src_paths=[gpaths[srcIdOf(lang, templated)]],
                         out_flag_and_exe=['-o', out_binary(lang)],
                         exe=exe,
                         runner=True,
                         comp_flags=C_CLANG_FLAGS + comp_flags,
                         args=args,
                         op=op,
                         compiler_version=version,
                         lang=lang,
                         templated=templated,
                         results=results,
                         durs=durs)
    return results


def benchmark_D(execs, durs, gpaths, args, op, templated, use_dips):
    results = list()
    lang = 'D'
    d_flags = ['-w', '-dip25', '-dip1008', '-dip1000'] if use_dips else []  # use DIPs

    src_paths = [gpaths[srcIdOf(lang, templated)]  # ,
                 # create_D_object_file() # TODO add later
                 ]

    if op == 'Build':
        if which('ld.lld') is not None:
            comp_flags = ["-Xcc=-fuse-ld=lld"]
        elif which('ld.gold') is not None:
            comp_flags = ["-Xcc=-fuse-ld=gold"]
        else:
            comp_flags = []
    else:
        comp_flags = ['-o-']

    # DMD
    exe = which('dmd')
    if exe is not None:
        opId = opIdOf(lang, templated, op, 'dmd')
        version = get_version(sp.run([exe, '--version'], stdout=sp.PIPE))
        if opId not in execs:
            execs[opId] = exe
        compile_file(src_paths=src_paths,
                     out_flag_and_exe=['-of=' + out_binary(lang)],
                     exe=exe,
                     runner=True,
                     comp_flags=d_flags + comp_flags,
                     args=args,
                     op=op,
                     compiler_version=version,
                     lang=lang,
                     templated=templated,
                     results=results,
                     durs=durs)

    # LDC
    exe = which('ldmd2')
    if exe is not None:
        opId = opIdOf(lang, templated, op, 'ldmd2')
        version = sp.run([exe, '--version'], stdout=sp.PIPE).stdout.decode('utf-8').split()[6][1:-2]
        if opId not in execs:
            execs[opId] = exe
        compile_file(src_paths=src_paths,
                     out_flag_and_exe=['-of=' + out_binary(lang)],
                     exe=exe,
                     runner=True,
                     comp_flags=d_flags + comp_flags,
                     args=args,
                     op=op,
                     compiler_version=version,
                     lang=lang,
                     templated=templated,
                     results=results,
                     durs=durs)

    # GDC
    if args.function_count * args.function_depth <= 10000:
        exe = which('gdc')
        if exe is not None:
            comp_flags = [] if op == 'Build' else ['-fsyntax-only']
            opId = opIdOf(lang, templated, op, 'gdc')
            version = sp.run([exe, '--version'], stdout=sp.PIPE).stdout.decode('utf-8').split()[3]
            if opId not in execs:
                execs[opId] = exe
            compile_file(src_paths=src_paths,
                         out_flag_and_exe=['-o', out_binary(lang)],
                         exe=exe,
                         runner=True,
                         comp_flags=comp_flags,
                         args=args,
                         op=op,
                         compiler_version=version,
                         lang=lang,
                         templated=templated,
                         results=results,
                         durs=durs)
    return results


def benchmark_Vox(execs, durs, gpaths, args, op, templated):
    results = list()
    lang = 'Vox'

    comp_flags = [] if op == 'Build' else ['--check-only']
    src_paths = [gpaths[srcIdOf(lang, templated)]]

    exe = which('vox')
    if exe is not None:
        opId = opIdOf(lang, templated, op, 'vox')
        version = 'master'      # TODO lookup Git version
        if opId not in execs:
            execs[opId] = exe
        compile_file(src_paths=src_paths,
                     out_flag_and_exe=['--of=' + out_binary(lang)],
                     exe=exe,
                     runner=True,  # os.name == 'nt', # only on Windows for now. TODO https://forum.dlang.org/post/cjbaiikzfbqkjqoukljc@forum.dlang.org
                     comp_flags=comp_flags,
                     args=args,
                     op=op,
                     compiler_version=version,
                     lang=lang,
                     templated=templated,
                     results=results,
                     durs=durs)
    return results


def benchmark_Mono(execs, durs, gpaths, args, op, templated):
    results = list()
    lang = 'C#'
    exe = which('mcs')
    comp_flags = ['-target:exe']
    comp_flags += [] if op == 'Build' else ['']
    if exe is not None:
        execs[lang] = exe
        version = sp.run([exe, '--version'], stdout=sp.PIPE).stdout.decode('utf-8').split()[4]
        compile_file(src_paths=[gpaths[srcIdOf(lang, templated)]],
                     out_flag_and_exe=['-out:' + out_binary(lang)],
                     exe=exe,
                     runner=True,
                     comp_flags=comp_flags,
                     args=args,
                     op=op,
                     compiler_version=version,
                     lang=lang,
                     templated=templated,
                     results=results,
                     durs=durs)
    return results


def benchmark_Go(execs, durs, gpaths, args, op, templated):
    results = list()
    results += benchmark_Go_using_go(execs, durs, gpaths, args, op, templated)
    results += benchmark_Go_using_gccgo(execs, durs, gpaths, args, op, templated)
    return results


def benchmark_Go_using_go(execs, durs, gpaths, args, op, templated):
    results = list()
    lang = 'Go'
    version = None              # unknown
    if op == 'Build':
        exe = which('go')
        comp_flags = ['build']
        version = sp.run([exe, 'version'], stdout=sp.PIPE).stdout.decode('utf-8').split()[2][2:]
        out_flag_and_exe = ['-o', out_binary(lang)]
    else:
        exe = which('gotype')
        comp_flags = []
        version_exe = which('go')  # guess it be same as `go`
        if version_exe is not None:
            version = sp.run([version_exe, 'version'], stdout=sp.PIPE).stdout.decode('utf-8').split()[2][2:]
        out_flag_and_exe = []
    if exe is not None:
        execs[lang] = exe
        compile_file(src_paths=[gpaths[srcIdOf(lang, templated)]],
                     out_flag_and_exe=out_flag_and_exe,
                     exe=exe,
                     runner=True,
                     comp_flags=comp_flags,
                     args=args,
                     op=op,
                     compiler_version=version,
                     lang=lang,
                     templated=templated,
                     results=results,
                     durs=durs)
    return results


def benchmark_Go_using_gccgo(execs, durs, gpaths, args, op, templated):
    results = list()
    lang = 'Go'
    for gccgo_version in VERSIONS:
        exe = which('gccgo' + str(gccgo_version))
        comp_flags = [] if op == 'Build' else ['-fsyntax-only', '-S']
        if exe is not None:
            execs[lang] = exe
            version = sp.run([exe, '--version'], stdout=sp.PIPE).stdout.decode('utf-8').split()[3]
            compile_file(src_paths=[gpaths[srcIdOf(lang, templated)]],
                         out_flag_and_exe=[],  # TODO this fails out_flag_and_exe=['-o', out_binary(lang)],
                         exe=exe,
                         runner=True,
                         comp_flags=comp_flags,
                         args=args,
                         op=op,
                         compiler_version=version,
                         lang=lang,
                         templated=templated,
                         results=results,
                         durs=durs)
    return results


def benchmark_Swift(execs, durs, gpaths, args, op, templated):
    results = list()
    lang = 'Swift'
    exe = (which('swiftc') or
           which(os.path.join(HOME, '.local/swift-5.3.3-RELEASE-ubuntu20.04/usr/bin/swiftc')))
    version = sp.run([exe, '--version'], stdout=sp.PIPE).stdout.decode('utf-8').split()[2]
    if op == 'Build':
        comp_flags = ['']
    else:
        comp_flags = ['-typecheck']
    if exe is not None:
        execs[lang] = exe
        compile_file(src_paths=[gpaths[srcIdOf(lang, templated)]],
                     out_flag_and_exe=['-o', out_binary(lang)],
                     exe=exe,
                     runner=True,
                     comp_flags=comp_flags,
                     args=args,
                     op=op,
                     compiler_version=version,
                     lang=lang,
                     templated=templated,
                     results=results,
                     durs=durs)
    return results


def benchmark_OCaml(execs, durs, gpaths, args, op, templated, bytecode):
    results = list()
    lang = 'OCaml'
    if bytecode:
        exe = which('ocamlc')
    else:
        exe = which('ocamlopt')
    if exe is not None:
        execs[lang] = exe
        version = sp.run([exe, '--version'], stdout=sp.PIPE).stdout.decode('utf-8').split()[0]
        compile_file(src_paths=[gpaths[srcIdOf(lang, templated)]],
                     out_flag_and_exe=['-o', out_binary(lang)],
                     exe=exe,
                     runner=([which('ocamlrun')] if
                             bytecode else
                             True),
                     comp_flags=['-c'] if bytecode else [],
                     args=args,
                     op=op,
                     compiler_version=version,
                     lang=lang,
                     templated=templated,
                     results=results,
                     durs=durs)
    return results


def benchmark_V(execs, durs, gpaths, args, op, templated):
    results = list()
    lang = 'V'                                   # vlang.io
    exe = (which('v') or
           which(os.path.join(HOME, 'ware/vlang/v')))
    if exe is not None:
        execs[lang] = exe
        version = sp.run([exe, '--version'], stdout=sp.PIPE).stdout.decode('utf-8').split()[1]
        vlang_backends = ['c', 'js', 'x64', 'v2', 'experimental']
        compile_file(src_paths=[gpaths[srcIdOf(lang, templated)]],
                     out_flag_and_exe=['-o', out_binary(lang)],
                     exe=exe,
                     runner=True,
                     comp_flags=['-backend', vlang_backends[2]], # skip '-cc clang' for now
                     args=args,
                     op=op,
                     compiler_version=version,
                     lang=lang,
                     templated=templated,
                     results=results,
                     durs=durs)
    return results


def benchmark_C3(execs, durs, gpaths, args, op, templated):
    results = list()
    lang = 'C3'
    exe = (which('c3c') or
           which(os.path.join(HOME, 'ware/c3c/build/c3c')))
    if exe is not None:
        execs[lang] = exe
        version = 'unknown'
        compile_file(src_paths=[gpaths[srcIdOf(lang, templated)]],
                     out_flag_and_exe=['-o', out_binary(lang)],
                     exe=exe,
                     runner=True,
                     comp_flags=['compile'],
                     args=args,
                     op=op,
                     compiler_version=version,
                     lang=lang,
                     templated=templated,
                     results=results,
                     durs=durs)
    return results


def benchmark_Zig(execs, durs, gpaths, args, op, templated):
    results = list()
    lang = 'Zig'
    exe = which('zig')
    comp_flags = ['build-exe'] if op == 'Build' else ['build-obj', '-fno-emit-bin']
    if exe is not None:
        execs[lang] = exe
        version = sp.run([exe, 'version'], stdout=sp.PIPE).stdout.decode('utf-8').split()[0]
        compile_file(src_paths=[gpaths[srcIdOf(lang, templated)]],
                     out_flag_and_exe=['--name', out_binary(lang)],
                     exe=exe,
                     runner=True,
                     comp_flags=comp_flags,
                     args=args,  # no syntax flag currently so compile to object file instead
                     op=op,
                     compiler_version=version,
                     lang=lang,
                     templated=templated,
                     results=results,
                     durs=durs)
    return results


def benchmark_Nim(execs, durs, gpaths, args, op, templated):
    results = list()
    lang = 'Nim'
    exe = which('nim')
    comp_flags = ['--hints:off']
    if op == 'Check':
        comp_flags += ['check']
    elif op == 'Build':
        comp_flags += ['c', '--gc:refc', '--opt:none']  # TODO detect when --gc:arc is available
    else:
        assert False
    if exe is not None:
        execs[lang] = exe
        version = sp.run([exe, '--version'], stdout=sp.PIPE).stdout.decode('utf-8').split()[3]
        compile_file(src_paths=[gpaths[srcIdOf(lang, templated)]],
                     out_flag_and_exe=['--out:' + out_binary(lang)],
                     exe=exe,
                     runner=True,
                     comp_flags=comp_flags,
                     args=args,  # no syntax flag currently so compile to object file instead
                     op=op,
                     compiler_version=version,
                     lang=lang,
                     templated=templated,
                     results=results,
                     durs=durs)
    return results


def set_rustup_channel(channel):
    with sp.Popen(['rustup', 'default', channel],
                  stdout=sp.PIPE,
                  stderr=sp.PIPE) as proc:
        proc.communicate()


def benchmark_Rust(execs, durs, gpaths, args, op, templated):
    results = list()
    lang = 'Rust'

    rustup_exe = which('rustup')
    if rustup_exe:
        rustup_channels = ['stable', 'nightly']
    else:
        rustup_channels = [None]

    for channel in rustup_channels:
        if rustup_exe is not None:
            set_rustup_channel(channel)

        exe = which('rustc')

        if exe is not None:
            opId = opIdOf(lang, templated, op, exe)
            if opId not in execs:
                execs[opId] = exe
                # See: https://stackoverflow.com/questions/53250631/does-rust-have-a-way-to-perform-syntax-and-semantic-analysis-without-generating/53250674#53250674
                # See: https://stackoverflow.com/questions/51485765/run-rustc-to-check-a-program-without-generating-any-files
                # Alternatives:
                # - `rustc --emit=metadata -Z no-codegen`
                # - Not yet in stable: `rustc -Z no-codegen`
                # - 'rustc', '--crate-type', 'lib', '--emit=mir', '-o', '/dev/null', '--test'
            version = sp.run([exe, '--version'], stdout=sp.PIPE).stdout.decode('utf-8').split()[1]
            if op == 'Check':
                if channel == 'nightly':
                    check_args = ['-Z', 'no-codegen']  # TODO why is this not available on stable yet?
                else:
                    check_args = ['--emit=mir', '-o', '/dev/null']  # Used by Flycheck. Twice as slow as `-Z no-codegen`
            comp_flags = ([] if op == 'Build' else check_args) + RUSTC_FLAGS
            compile_file(src_paths=[gpaths[srcIdOf(lang, templated)]],
                         out_flag_and_exe=['-o', out_binary(lang)],
                         exe=exe,
                         runner=True,
                         comp_flags=comp_flags,  # https://github.com/rust-lang/rfcs/issues/1476
                         args=args,
                         op=op,
                         compiler_version=version,
                         lang=lang,
                         templated=templated,
                         results=results,
                         durs=durs)
    return results

def benchmark_Java(execs, durs, gpaths, args, op, templated):
    results = list()
    lang = 'Java'
    exe = which('javac')
    if exe is not None:
        opId = opIdOf(lang, templated, op, exe)
        execs[opId] = exe
        try:
            task = sp.run([exe, '-version'],
                          stdout=sp.PIPE,
                          stderr=sp.PIPE)
            version = (task.stdout or task.stderr).decode('utf-8').split()[1]
        except:
            print("WARNING: Failed to decode version from neither stdout:" + str(task.stdout) + " nor stderr:" + str(task.stderr) +
                  " of command " + str([exe, '-version']) + ", defaulting version of " + lang + " to `none`",
                  file=sys.stderr)
            version = 'unknown'
        compile_file(src_paths=[gpaths[srcIdOf(lang, templated)]],
                     out_flag_and_exe=[],
                     exe=exe,
                     runner=[which('java'),
                             '-classpath', os.path.join(ROOT_PATH, lang.lower())],
                     comp_flags=['-Xdiags:verbose'],
                     args=args,
                     op=op,
                     compiler_version=version,
                     lang=lang,
                     templated=templated,
                     results=results,
                     durs=durs)
    return results


def benchmark_Julia(execs, durs, gpaths, args, op, templated):
    results = list()
    lang = 'Julia'
    exe = which('julia')
    if exe is not None:
        opId = opIdOf(lang, templated, op, exe)
        execs[opId] = exe
        version = sp.run([exe, '--version'], stdout=sp.PIPE).stdout.decode('utf-8').split()[2]
        compile_file(src_paths=[gpaths[srcIdOf(lang, templated)]],
                     out_flag_and_exe=[],
                     exe=exe,
                     runner=False,
                     comp_flags=[],
                     args=args,
                     op=op,
                     compiler_version=version,
                     lang=lang,
                     templated=templated,
                     results=results,
                     durs=durs)
    return results


def compile_file(src_paths,
                 out_flag_and_exe,
                 exe,
                 runner,
                 comp_flags,
                 args,
                 op='Check',
                 compiler_version=None,
                 lang=None,
                 templated=None,
                 results=None,
                 durs=None):

    compiler = which(exe)
    if compiler is None:
        print('WARNING: Could not find compiler:', exe,
              file=sys.stderr)
        return None

    # op
    cdurs = []                  # compilation durations
    rss_mu = None               # RSS memory usage
    for _ in range(0, args.run_count):
        cstart = timer()        # compilation start
        p_args = [exe] + comp_flags + out_flag_and_exe + src_paths
        # print("p_args:", ' '.join(p_args))
        pt = ProcessTimer(args=p_args)
        try:
            while pt.poll():
                time.sleep(0.01)  # poll as often as possible
        finally:
            outs, errs = pt.comp_proc.communicate()
            if rss_mu is None and pt.max_rss_mu != 0:
                rss_mu = pt.max_rss_mu
            # TODO pt.assertClosed()

        # print('Compilation:', ' '.join([exe] + comp_flags + out_flag_and_exe + src_paths))
        if pt.comp_proc.returncode != 0:
            print("WARNING: Compilation `" + ' '.join([exe] + comp_flags) +
                  "` of source files `" + ' '.join(src_paths) +
                  "` exited with return code " + str(pt.comp_proc.returncode),
                  file=sys.stderr)
            return None

        cdurs.append(timer() - cstart)

        if outs:
            if not outs.startswith(b'/usr/bin/ld: warning'):
                print('stdout:', outs)
        if errs:
            if lang == 'Ada':
                errs = errs.lstrip(b'x86_64-linux-gnu-gcc-10 -c -Igenerated/ada/ -I- generated/ada/main.adb\n')
            if len(errs) and not errs.startswith(b'/usr/bin/ld: warning'):  # skip ld warning
                print('output:', errs)
    cdur_min = min(cdurs)       # compilation duration minimum

    # run
    rdur_min = None             # run duration minimum
    if op == 'Build':
        outb = out_binary(lang)
        if runner:
            if runner is True:      # binary should be runnable
                if (exe.endswith('cproc')):  # cproc forgets to set executable bit
                    st = os.stat(exe)
                    os.chmod(outb, st.st_mode | stat.S_IEXEC)
                rdur_min = run_compiled_file(exe)
            elif type(runner) is list:
                rdur_min = run_compiled_file(runner + [outb])
        elif out_flag_and_exe:
            if runner is not False:
                print("TODO run " + outb + " using runner " + str(runner))

    opId = opIdOf(lang, templated, op, exe)

    print(markdown_header(opId + ':', 2))

    show_file = False
    compiler_version_str = ' version ' + str(compiler_version) if compiler_version is not None else ''
    if show_file:
        print('- {} of {} took {:1.3f} seconds (using "{}"{})'.format(op, src_paths, cdur_min, exe,
                                                                      compiler_version_str))
    else:
        print('- {} took {:1.3f} seconds (using "{}"{})'.format(op, cdur_min, exe,
                                                                compiler_version_str))

    results.append(table_row(args=args,
                             lang=lang,
                             op=op,
                             exe_path=exe,
                             compiler_version=compiler_version,
                             cdur=cdur_min if op == 'Check' else None,
                             bdur=cdur_min if op == 'Build' else None,
                             rdur=rdur_min,
                             rss_mu=rss_mu,
                             templated=templated))
    durs[opId] = cdur_min

    print_speedup(durs,
                  from_opId=opIdOf('D', templated, op, 'dmd'),
                  to_opId=opId)


def run_compiled_file(args, run_count=1):
    durs = []                  # compilation durations
    for _ in range(0, run_count):
        cstart = timer()        # compilation start
        # print("args:", args)
        with sp.Popen(args,
                      stdout=sp.PIPE,
                      stderr=sp.PIPE) as comp_proc:
            outs, errs = comp_proc.communicate()
            # pprint(comp_proc.__dict__)
            # TODO detect segfault exit code
            # if comp_proc.returncode != 0:
            #     print("WARNING: Run of compiled exec `" + str(args) +
            #           "` exited with return code " + str(comp_proc.returncode),
            #           file=sys.stderr)
            #     return None
            durs.append(timer() - cstart)
    dur_min = min(durs)         # running duration minimum
    return dur_min


def long_types_of_lang(lang):
    if lang in ('c', 'c3', 'c++', 'c#', 'java'):
        return ['long']
    elif lang in ('rust', 'zig', 'v', 'vox', 'c3'):
        return ['i64']
    elif lang in 'swift':
        return ['Int64']
    elif lang == 'd':
        return ['long']
    elif lang in ('go', 'nim'):
        return ['int64']
    elif lang == 'julia':
        return ['Int64']
    elif lang == 'ocaml':
        return ['float']
    elif lang == 'ada':
        return ['Long_Integer']  # gnat
    else:
        return None


def language_file_extension(lang):
    if lang == 'rust':
        return 'rs'
    elif lang == 'julia':
        return 'jl'
    elif lang == 'ocaml':
        return 'ml'
    elif lang == 'c#':
        return 'cs'
    elif lang == 'vox':
        return 'vx'
    elif lang == 'ada':
        return 'adb'
    else:
        return lang


def generate_test_program(lang,
                          args,
                          templated):
    program_name = DEFAULT_PROGRAM_NAME

    llang = lang.lower()        # lowered language
    types = long_types_of_lang(llang)
    ext = language_file_extension(llang)
    dir_path = os.path.join(ROOT_PATH, llang)
    os.makedirs(dir_path, exist_ok=True)

    path = os.path.join(dir_path, program_name + ('_t' if templated else '') + '.' + ext)

    start = timer()
    with open(path, 'w') as f:
        generate_test_language_specific_prefix(llang, program_name, f, templated=templated)

        if llang == 'ada':
            generate_test_main_header(llang, types, f, templated)
            generate_main_test_function_definition_set(llang, types, args, f,
                                                       templated=templated)
        else:
            generate_main_test_function_definition_set(llang, types, args, f,
                                                       templated=templated)
            generate_test_main_header(llang, types, f, templated)

        for typ in types:
            generate_main_test_function_variable(llang, typ, f, templated=templated)

        generate_test_main_middle(llang, types, f, templated)

        for typ in types:
            for findex in range(0, args.function_count):
                generate_test_function_call(llang, findex, typ, f, templated=templated)

        generate_test_language_specific_postfix(llang, types, f)
    end = timer()
    dur = (end - start)  # time dur
    print('- Generating {} took {:1.3f} seconds ({})'.format(path, dur, lang))
    # print('Generated {} source file: {}'.format(llang.upper(), path))

    return path


def generate_test_function_call(lang, findex, typ, f, templated):
    if lang in ('c#', 'java'):
        f.write('    ')

    if lang == 'zig' and templated:  # Zig needs explicit template type
        f.write(Tm('    ${T}_sum += add_${T}_n${N}(${T}, ${N})').substitute(T=typ, N=str(findex)))
    elif lang == 'v' and templated:  # Zig needs explicit template type for now. See: https://github.com/vlang/v/issues/5818
        f.write(Tm('    ${T}_sum += add_${T}_n${N}<${T}>(${N})').substitute(T=typ, N=str(findex)))
    elif lang == 'ocaml':
        f.write(Tm('    let ${T}_sum = ${T}_sum +. (add_${T}_n${N} ${N}.0) in').substitute(T=typ, N=str(findex)))
    elif lang == 'ada':
        f.write(Tm('   ${T}_sum := ${T}_sum + add_${T}_n${N}(${N})').substitute(T=typ, N=str(findex)))
    elif lang == 'vox':
        f.write(Tm('    ${T}_sum += add_${T}_n${N}${X}(${N})').substitute(T=typ,
                                                                          N=str(findex),
                                                                          X='[' + typ + ']' if templated else ''))
    elif lang == 'swift':
        f.write(Tm('    ${T}_sum += add_${T}_n${N}(x: ${N})').substitute(T=typ, N=str(findex)))
    else:
        f.write(Tm('    ${T}_sum += add_${T}_n${N}(${N})').substitute(T=typ, N=str(findex)))

    if lang not in ('ocaml', 'nim', 'v'):
        f.write(';')            # statement terminator

    f.write('\n')


def generate_test_language_specific_prefix(lang, program_name, f, templated):
    if lang == 'go':
        f.write('package ' + program_name + ';\n')
        f.write('// import ("os")\n\n')  # fails with `gotype`
    elif lang == 'rust':
        f.write('use std::process::exit;\n')
        if templated:
            f.write('use std::ops::Add;\n')
    elif lang == 'swift':
        f.write('import Foundation\n\n')
    elif lang == 'c#':
        f.write('using System;\n\n')
        f.write('public class HelloWorld {\n')
    elif lang == 'java':
        f.write('class HelloWorld {\n')
    elif lang == 'ada':
        f.write('with System;\n\n')
        f.write('with GNAT.OS_Lib;\n\n')
    elif lang == 'vox':
        f.write('''enum u32 stdin = 0;
enum u32 stdout = 1;
enum u32 stderr = 2;

@extern(syscall, 60)
void exit(i32 error_code);

@extern(syscall, 1)
void sys_write(u32 fd, u8* buf, u64 count);

void write(u32 fd, u8[] data) {
	sys_write(fd, data.ptr, data.length);
}
''')


def generate_test_language_specific_postfix(lang, types, f):
    if lang == 'rust':
        f.write(Tm('    exit((${T}_sum % 4294967296) as i32);\n}\n').substitute(T=types[0]))
    elif lang == 'd':
        f.write(Tm('    return cast(int)${T}_sum;\n}\n').substitute(T=types[0]))
    elif lang == 'nim':
        f.write(Tm('    quit(int(${T}_sum))\n\n').substitute(T=types[0]))
    elif lang == 'swift':
        f.write(Tm('    exit(Int32(${T}_sum))\n}\n').substitute(T=types[0]))
    elif lang == 'go':
        f.write(Tm('    // os.Exit(int(${T}_sum));\n').substitute(T=types[0]))
        f.write(Tm('}\n').substitute(T=types[0]))
    elif lang == 'c#':
        f.write(Tm('        Environment.Exit(${T}_sum == 42 ? 1 : 0);\n    }\n').substitute(T=types[0]))
    elif lang == 'java':
        f.write(Tm('        System.exit(${T}_sum == 42 ? 1 : 0);\n    }\n').substitute(T=types[0]))
    elif lang == 'zig':
        f.write(Tm('\n}\n').substitute(T=types[0]))
    elif lang == 'nim':
        f.write(Tm('\n\n').substitute(T=types[0]))
    elif lang == 'c3':
        f.write(Tm('\n}\n').substitute(T=types[0]))  # TODO exit
    elif lang == 'julia':
        f.write(Tm('''    return ${T}_sum;
end

main()
''').substitute(T=types[0]))
    elif lang == 'd':
        f.write(Tm('''    return cast(int)${T}_sum;
}
''').substitute(T=types[0]))
    elif lang == 'vox':
        # TODO: use exit(i32(${T}_sum)) when it doesnâ€™t segfault:
        f.write(Tm('''    exit(0);
    return 0;
}
''').substitute(T=types[0]))
    elif lang == 'ada':
        f.write(Tm('''   GNAT.OS_Lib.OS_Exit(Integer(${T}_sum));
end Main;
''').substitute(T=types[0]))
    elif lang == 'ocaml':
        f.write(Tm('    exit (if ${T}_sum = 42.0 then 1 else 0)\n').substitute(T=types[0]))
    elif lang == 'v':
        f.write(Tm('''    exit(int(${T}_sum >> 32))\n}\n''').substitute(T=types[0]))
    else:
        f.write(Tm('''    return ${T}_sum;\n}\n''').substitute(T=types[0]))

    if lang in ('c#', 'java'):
        f.write('}\n')            # one extra closing brace for class


def generate_main_test_function_definition_set(lang, types, args, f,
                                               templated):
    for typ in types:
        for findex in range(0, args.function_count):
            for fheight in range(0, args.function_depth):
                generate_test_function_definition(args, lang, typ, findex, fheight, f,
                                                  templated=templated)
            f.write('\n')
        f.write('\n')


def function_name(typ, findex, fheight):
    if fheight is not None:
        return Tm('add_${T}_n${N}_h${H}').substitute(T=typ,
                                                     N=str(findex),
                                                     H=str(fheight))
    else:
        return Tm('add_${T}_n${N}').substitute(T=typ,
                                               N=str(findex))


def generate_test_function_definition(args, lang, typ, findex, fheight, f,
                                      templated):
    if RANDOMIZE_FLAG:
        nconst = str(random.randint(0, 100000))
    else:
        nconst = str(findex)

    if fheight == 0:
        if lang == 'rust' and templated:
            expr = 'x'          # because Rust is picky
        elif lang == 'ocaml':
            expr = 'x +. ' + nconst + '.0'
        else:
            expr = 'x + ' + nconst
    else:
        if lang == 'zig' and templated:
            xtarg = typ + ', '  # Zig needs explicit template parameter
        else:
            xtarg = ''
        if lang == 'rust' and templated:
            call = function_name(typ, findex, fheight - 1) + '(' + xtarg + 'x)'
            expr = 'x + ' + call
        elif lang == 'v' and templated:
            call = function_name(typ, findex, fheight - 1) + Tm('<${T}>(x)').substitute(T=typ)
            expr = 'x + ' + call
        elif lang == 'vox' and templated:
            call = function_name(typ, findex, fheight - 1) + Tm('[${T}](x)').substitute(T=typ)
            expr = 'x + ' + call
        elif lang == 'ocaml':
            expr = 'x +. (' + function_name(typ, findex, fheight - 1) + xtarg + ' x) +. ' + nconst + '.0'
        elif lang == 'swift':
            expr = 'x + ' + function_name(typ, findex, fheight - 1) + '(x: ' + xtarg + 'x) + ' + nconst
        else:
            expr = 'x + ' + function_name(typ, findex, fheight - 1) + '(' + xtarg + 'x) + ' + nconst

    if fheight == args.function_depth - 1:
        fname = function_name(typ, findex, fheight=None)
    else:
        fname = function_name(typ, findex, fheight)

    if lang in ('c'):
        f.write(Tm('${T} ${F}(${T} x) { return ${X}; }\n').substitute(T=typ, F=str(fname), N=nconst, X=expr))
    elif lang in ('c3'):
        f.write(Tm('func ${T} ${F}(${T} x) { return ${X}; }\n').substitute(T=typ, F=str(fname), N=nconst, X=expr))
    elif lang in ['ada']:
        f.write(Tm('''   function ${F} (x: ${T}) return ${T} is (${X});
''').substitute(T=typ, F=str(fname), N=nconst, X=expr))
    elif lang in ['c#']:
        f.write(Tm('    static ${T} ${F}(${T} x) { return ${X}; }\n').substitute(T=typ, F=str(fname), N=nconst, H=str(fheight), X=expr))
    elif lang in ['java']:
        f.write(Tm('    static ${T} ${F}(${T} x) { return ${X}; }\n').substitute(T=typ, F=str(fname), N=nconst, H=str(fheight), X=expr))
    elif lang in ['c++']:
        f.write(Tm('${M}${T} ${F}(${T} x) { return ${X}; }\n')
                .substitute(T=typ, F=str(fname), N=nconst, H=str(fheight),
                            M='template<typename T=int> ' if templated else '',
                            X=expr))
        # template<typename T1, typename T2 = int> class A;
    elif lang in ('d', 'vox'):
        # See: https://forum.dlang.org/post/sfldpxiieahuiizvgjeb@forum.dlang.org
        f.write(Tm('${T} ${F}${M}(${T} x)${Q} { return ${X}; }\n')
                .substitute(T='T' if templated else typ,
                            F=str(fname),
                            N=nconst,
                            H=str(fheight),
                            M=('(T)' if lang == 'd' else '[T]') if templated else '',
                            Q=' @safe pure nothrow @nogc' if lang == 'd' else '',
                            X=expr))
    elif lang == 'rust':
        if templated:
            f.write(Tm('fn ${F}<${T} : ${R}>(x: ${T}) -> ${T} { ${X} }\n').substitute(T='T',
                                                                                      R='Copy + Add<Output = T>',
                                                                                      F=str(fname),
                                                                                      N=nconst,
                                                                                      H=str(fheight),
                                                                                      X=expr))
        else:
            f.write(Tm('fn ${F}(x: ${T}) -> ${T} { ${X} }\n').substitute(T=typ, F=str(fname), N=nconst, H=str(fheight), X=expr))
    elif lang == 'swift':
        if templated:
            f.write(Tm('func ${F}<${T}>(x: ${T}) -> ${T} { return ${X} }\n').substitute(T='T',
                                                                                        F=str(fname),
                                                                                        N=nconst,
                                                                                        H=str(fheight),
                                                                                        X=expr))
        else:
            f.write(Tm('func ${F}(x: ${T}) -> ${T} { return ${X} }\n').substitute(T=typ, F=str(fname), N=nconst, H=str(fheight), X=expr))
    elif lang == 'nim':
        if templated:
            f.write(Tm('proc ${F}<${T}>(x: ${T}): ${T} =\n  return ${X}\n').substitute(T='T',
                                                                                       F=str(fname),
                                                                                       N=nconst,
                                                                                       H=str(fheight),
                                                                                       X=expr))
        else:
            f.write(Tm('proc ${F}(x: ${T}): ${T} = \n  return ${X}\n').substitute(T=typ, F=str(fname), N=nconst, H=str(fheight), X=expr))
    elif lang == 'c3':
        if templated:
            f.write(Tm('func ${F}<${T}>(x: ${T}) -> ${T} { return ${X} }\n').substitute(T='T',
                                                                                        F=str(fname),
                                                                                        N=nconst,
                                                                                        H=str(fheight),
                                                                                        X=expr))
        else:
            f.write(Tm('func ${T} ${F}(${T} x) { return ${X} }\n').substitute(T=typ, F=str(fname), N=nconst, H=str(fheight), X=expr))
    elif lang == 'zig':
        if templated:
            f.write(Tm('fn ${F}(comptime T: type, x: T) T { return ${X}; }\n').substitute(T=typ, F=str(fname), N=nconst, H=str(fheight), X=expr))
        else:
            f.write(Tm('fn ${F}(x: ${T}) ${T} { return ${X}; }\n').substitute(T=typ, F=str(fname), N=nconst, H=str(fheight), X=expr))
    elif lang == 'go':
        f.write(Tm('func ${F}(x ${T}) ${T} { return ${X} }\n').substitute(T=typ, F=str(fname), N=nconst, H=str(fheight), X=expr))
    elif lang == 'ocaml':
        f.write(Tm('let ${F} x = ${X}\n').substitute(F=str(fname), X=expr))
    elif lang == 'v':
        if templated:
            f.write(Tm('fn ${F}<${T}>(x ${T}) ${T} { return ${X} }\n').substitute(T='T', F=str(fname), N=nconst, H=str(fheight), X=expr))
        else:
            f.write(Tm('fn ${F}(x ${T}) ${T} { return ${X} }\n').substitute(T=typ, F=str(fname), N=nconst, H=str(fheight), X=expr))
    elif lang == 'julia':
        f.write(Tm('function ${F}(x${QT})${QT}\n    return ${X}\nend;\n').substitute(QT=('' if templated else ('::' + typ)),
                                                                                     F=str(fname), N=nconst, H=str(fheight), X=expr))


def generate_test_main_header(lang, types, f, templated):
    if lang in ['c', 'c++']:
        # `cproc` cannot handle this skip for now:
        # f.write('int main(__attribute__((unused)) int argc, __attribute__((unused)) char* argv[]) {\n')
        f.write('int main(void) {\n')
    elif lang == 'ada':
        f.write('procedure Main is\n')
    elif lang == 'c#':
        f.write('    public static void Main(string[] args) {\n')
    elif lang == 'java':
        f.write('    public static void main(String args[]) {\n')
    elif lang == 'd':
        f.write('int main() @safe {\n')
    elif lang == 'vox':
        f.write('i32 main() {\n')
    elif lang == 'rust':
        f.write(Tm('fn main() {\n').substitute(T=types[0]))
    elif lang == 'swift':
        f.write(Tm('func main() {\n').substitute(T=types[0]))
    elif lang == 'zig':
        f.write(Tm('pub fn main() void {\n').substitute(T=types[0]))
    elif lang == 'c3':
        f.write(Tm('func void main() {\n').substitute(T=types[0]))
    elif lang == 'go':
        f.write(Tm('func main() {\n').substitute(T=types[0]))
    elif lang == 'v':
        f.write(Tm('fn main() {\n').substitute(T=types[0]))
    elif lang == 'julia':
        f.write(Tm('function main()${QT}\n').substitute(QT=(('::' + types[0]) if templated else '')))
    elif lang == 'ocaml':
        f.write('let () = \n')
    elif lang == 'nim':
        f.write('when isMainModule:\n')
    else:
        assert False


def generate_test_main_middle(lang, types, f, templated):
    if lang == 'ada':
        f.write('begin\n')


def generate_main_test_function_variable(lang, typ, f, templated):
    if lang in ('c', 'c3', 'c++', 'd', 'vox'):
        f.write(Tm('    ${T} ${T}_sum = 0;\n').substitute(T=typ))
    elif lang in ['ada']:
        f.write(Tm('   ${T}_sum : ${T} := 0;\n').substitute(T=typ))
    elif lang in ['c#']:
        f.write(Tm('        ${T} ${T}_sum = 0;\n').substitute(T=typ))
    elif lang in ['java']:
        f.write(Tm('        ${T} ${T}_sum = 0;\n').substitute(T=typ))
    elif lang == 'rust':
        f.write(Tm('    let mut ${T}_sum : ${T} = 0;\n').substitute(T=typ))
    elif lang == 'swift':
        f.write(Tm('    var ${T}_sum: ${T} = 0;\n').substitute(T=typ))
    elif lang == 'nim':
        f.write(Tm('    var ${T}_sum: ${T} = 0;\n').substitute(T=typ))
    elif lang == 'zig':
        f.write(Tm('    var ${T}_sum: ${T} = 0;\n').substitute(T=typ))
    elif lang == 'go':
        f.write(Tm('    var ${T}_sum ${T} = 0;\n').substitute(T=typ))
    elif lang == 'v':
        f.write(Tm('    mut ${T}_sum := ${T}(0)\n').substitute(T=typ))
    elif lang == 'julia':
        f.write(Tm('    ${T}_sum${QT} = 0;\n').substitute(T=typ, QT=(('::' + typ) if templated else '')))
    elif lang == 'ocaml':
        f.write(Tm('    let ${T}_sum = 0.0 in\n').substitute(T=typ))
    else:
        assert False


def generate_test_program_2(function_count, lang, templated):
    program_name = 'sample2'

    lang = lang.lower()
    types = long_types_of_lang(lang)
    ext = language_file_extension(lang)
    dir_path = os.path.join(ROOT_PATH, lang)
    os.makedirs(dir_path, exist_ok=True)
    path = os.path.join(dir_path, program_name + '.' + ext)

    start = timer()
    with open(path, 'w') as f:

        # package definition
        if lang == 'go':
            f.write('''package ''' + program_name + ''';

''')

        # standard io module
        if lang in ['c']:
            f.write('''#include <stdio.h>
''')
        if lang in ['c++']:
            f.write('''#include <iostream>
''')
        if lang in ('d', 'vox'):
            f.write('''import std.stdio;
''')
        if lang == 'rust':
            f.write('''use std::io;
''')
        if lang == 'c3':
            f.write('''import std::io;
''')
        if lang == 'go':
            f.write('''import "fmt";

''')
        if lang == 'v':
            f.write('''import os
''')

        # special modules
        if lang == 'rust':
            f.write('''use std::process::exit;
''')

        for typ in types:
            for findex in range(0, function_count):
                if lang in ('c', 'c3', 'c++'):
                    f.write(Tm('''${T} add_${T}_n${N}(${T} x) { return x + ${N}; }
''').substitute(T=typ, N=str(findex)))
                if lang in ('d', 'vox'):
                    f.write(Tm('''${T} add_${T}_n${N}(${T} x) pure { return x + ${N}; }
''').substitute(T=typ, N=str(findex)))
                elif lang == 'rust':
                    f.write(Tm('''fn add_${T}_n${N}(x: ${T}) -> ${T} { x + ${N} }
''').substitute(T=typ, N=str(findex)))
                elif lang == 'zig':
                    f.write(Tm('''fn add_${T}_n${N}(x: ${T}) ${T} { return x + ${N}; }
''').substitute(T=typ, N=str(findex)))
                elif lang == 'go':
                    f.write(Tm('''func add_${T}_n${N}(x ${T}) ${T} { return x + ${N} }
''').substitute(T=typ, N=str(findex)))
                elif lang == 'ocaml':
                    f.write(Tm('''let add_${T}_n${N} x = x +. ${N}.0
''').substitute(T=typ, N=str(findex)))
                elif lang == 'v':
                    f.write(Tm('''fn add_${T}_n${N}(x ${T}) ${T} { return x + ${N} }
''').substitute(T=typ, N=str(findex)))
                elif lang == 'julia':
                    f.write(Tm('''function add_${T}_n${N}(x${QT})${QT}
    return x + ${N}
end;
''').substitute(QT=('' if templated else ('::' + typ)), N=str(findex)))
                    f.write('\n')

        # MAIN HEADER
        if lang in ['c', 'c++']:
            f.write('''int main(__attribute__((unused)) int argc, __attribute__((unused)) char* argv[])
{
''')
        elif lang in ('d', 'vox'):
            f.write('''int main(string[] args)
{
''')
        elif lang == 'rust':
            f.write(Tm('''fn main() {
''').substitute(T=types[0]))
        elif lang == 'zig':
            f.write(Tm('''pub fn main() void {
''').substitute(T=types[0]))
        elif lang == 'go':
            f.write(Tm('''func main() ${T} {
''').substitute(T=types[0]))
        elif lang == 'v':
            f.write(Tm('''fn main() ${T} {
''').substitute(T=types[0]))
        elif lang == 'julia':
            f.write(Tm('''function main()::${T}
''').substitute(T=types[0]))
        else:
            assert False

        # CALCULATE
        for typ in types:
            if lang in ('c', 'c3', 'c++', 'd', 'vox'):
                f.write(Tm('''    ${T} ${T}_sum = 0;
''').substitute(T=typ))
            elif lang == 'rust':
                f.write(Tm('''    let mut ${T}_sum : ${T} = 0;
''').substitute(T=typ))
            elif lang == 'zig':
                f.write(Tm('''    var ${T}_sum: ${T} = 0;
''').substitute(T=typ))
            elif lang == 'go':
                f.write(Tm('''    var ${T}_sum ${T} = 0;
''').substitute(T=typ))
            elif lang == 'v':
                f.write(Tm('''    var ${T}_sum ${T} = 0;
''').substitute(T=typ))
            elif lang == 'julia':
                f.write(Tm('''    ${T}_sum${QT} = 0;
''').substitute(QT=('' if templated else ('::' + typ))))
            else:
                assert False

            for findex in range(0, function_count):
                f.write(Tm('''    ${T}_sum += add_${T}_n${N}(${N});
''').substitute(T=typ, N=str(findex)))

        if lang == 'rust':
            f.write(Tm('''    exit(${T}_sum);
}
''').substitute(T=types[0]))
        elif lang == 'zig':
            f.write(Tm('''
}
''').substitute(T=types[0]))
        elif lang == 'ocaml':
            f.write(Tm('''    ${T}_sum''').substitute(T=types[0]))
        elif lang == 'julia':
            f.write(Tm('''    return ${T}_sum;
end

main()
''').substitute(T=types[0]))
        elif lang in ('d', 'vox'):
            f.write(Tm('''    return cast(int)${T}_sum;
}
''').substitute(T=types[0]))
        else:
            f.write(Tm('''    return ${T}_sum;
}
''').substitute(T=types[0]))

    end = timer()
    dur = (end - start)  # time dur
    print('- Generating {} took {:1.3f} seconds ({})'.format(path, dur, lang))

    # print('Generated {} source file: {}'.format(lang.upper(), path))

    return path


def print_speedup(durs, from_opId, to_opId):
    if (from_opId in durs) and (to_opId in durs):
        print('- Speedup of {} over {}: {:.2f}'.format(from_opId,
                                                       to_opId,
                                                       durs[to_opId] / durs[from_opId]))


if __name__ == '__main__':
    main()
